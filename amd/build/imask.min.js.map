{"version":3,"file":"imask.min.js","sources":["../src/imask.js"],"sourcesContent":["(function (global, factory) {\r\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\r\n        typeof define === 'function' && define.amd ? define(['exports'], factory) :\r\n            (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.IMask = {}));\r\n})(this, (function (exports) { 'use strict';\r\n\r\n    /** Checks if value is string */\r\n    function isString(str) {\r\n        return typeof str === 'string' || str instanceof String;\r\n    }\r\n\r\n    /** Checks if value is object */\r\n    function isObject(obj) {\r\n        var _obj$constructor;\r\n        return typeof obj === 'object' && obj != null && (obj == null || (_obj$constructor = obj.constructor) == null ? void 0 : _obj$constructor.name) === 'Object';\r\n    }\r\n    function pick(obj, keys) {\r\n        if (Array.isArray(keys)) return pick(obj, (_, k) => keys.includes(k));\r\n        return Object.entries(obj).reduce((acc, _ref) => {\r\n            let [k, v] = _ref;\r\n            if (keys(v, k)) acc[k] = v;\r\n            return acc;\r\n        }, {});\r\n    }\r\n\r\n    /** Direction */\r\n    const DIRECTION = {\r\n        NONE: 'NONE',\r\n        LEFT: 'LEFT',\r\n        FORCE_LEFT: 'FORCE_LEFT',\r\n        RIGHT: 'RIGHT',\r\n        FORCE_RIGHT: 'FORCE_RIGHT'\r\n    };\r\n\r\n    /** Direction */\r\n\r\n    function forceDirection(direction) {\r\n        switch (direction) {\r\n            case DIRECTION.LEFT:\r\n                return DIRECTION.FORCE_LEFT;\r\n            case DIRECTION.RIGHT:\r\n                return DIRECTION.FORCE_RIGHT;\r\n            default:\r\n                return direction;\r\n        }\r\n    }\r\n\r\n    /** Escapes regular expression control chars */\r\n    function escapeRegExp(str) {\r\n        return str.replace(/([.*+?^=!:${}()|[\\]/\\\\])/g, '\\\\$1');\r\n    }\r\n\r\n    // cloned from https://github.com/epoberezkin/fast-deep-equal with small changes\r\n    function objectIncludes(b, a) {\r\n        if (a === b) return true;\r\n        const arrA = Array.isArray(a),\r\n            arrB = Array.isArray(b);\r\n        let i;\r\n        if (arrA && arrB) {\r\n            if (a.length != b.length) return false;\r\n            for (i = 0; i < a.length; i++) if (!objectIncludes(a[i], b[i])) return false;\r\n            return true;\r\n        }\r\n        if (arrA != arrB) return false;\r\n        if (a && b && typeof a === 'object' && typeof b === 'object') {\r\n            const dateA = a instanceof Date,\r\n                dateB = b instanceof Date;\r\n            if (dateA && dateB) return a.getTime() == b.getTime();\r\n            if (dateA != dateB) return false;\r\n            const regexpA = a instanceof RegExp,\r\n                regexpB = b instanceof RegExp;\r\n            if (regexpA && regexpB) return a.toString() == b.toString();\r\n            if (regexpA != regexpB) return false;\r\n            const keys = Object.keys(a);\r\n            // if (keys.length !== Object.keys(b).length) return false;\r\n\r\n            for (i = 0; i < keys.length; i++) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\r\n            for (i = 0; i < keys.length; i++) if (!objectIncludes(b[keys[i]], a[keys[i]])) return false;\r\n            return true;\r\n        } else if (a && b && typeof a === 'function' && typeof b === 'function') {\r\n            return a.toString() === b.toString();\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /** Selection range */\r\n\r\n    /** Provides details of changing input */\r\n    class ActionDetails {\r\n        /** Current input value */\r\n\r\n        /** Current cursor position */\r\n\r\n        /** Old input value */\r\n\r\n        /** Old selection */\r\n\r\n        constructor(opts) {\r\n            Object.assign(this, opts);\r\n\r\n            // double check if left part was changed (autofilling, other non-standard input triggers)\r\n            while (this.value.slice(0, this.startChangePos) !== this.oldValue.slice(0, this.startChangePos)) {\r\n                --this.oldSelection.start;\r\n            }\r\n            if (this.insertedCount) {\r\n                // double check right part\r\n                while (this.value.slice(this.cursorPos) !== this.oldValue.slice(this.oldSelection.end)) {\r\n                    if (this.value.length - this.cursorPos < this.oldValue.length - this.oldSelection.end) ++this.oldSelection.end;else ++this.cursorPos;\r\n                }\r\n            }\r\n        }\r\n\r\n        /** Start changing position */\r\n        get startChangePos() {\r\n            return Math.min(this.cursorPos, this.oldSelection.start);\r\n        }\r\n\r\n        /** Inserted symbols count */\r\n        get insertedCount() {\r\n            return this.cursorPos - this.startChangePos;\r\n        }\r\n\r\n        /** Inserted symbols */\r\n        get inserted() {\r\n            return this.value.substr(this.startChangePos, this.insertedCount);\r\n        }\r\n\r\n        /** Removed symbols count */\r\n        get removedCount() {\r\n            // Math.max for opposite operation\r\n            return Math.max(this.oldSelection.end - this.startChangePos ||\r\n                // for Delete\r\n                this.oldValue.length - this.value.length, 0);\r\n        }\r\n\r\n        /** Removed symbols */\r\n        get removed() {\r\n            return this.oldValue.substr(this.startChangePos, this.removedCount);\r\n        }\r\n\r\n        /** Unchanged head symbols */\r\n        get head() {\r\n            return this.value.substring(0, this.startChangePos);\r\n        }\r\n\r\n        /** Unchanged tail symbols */\r\n        get tail() {\r\n            return this.value.substring(this.startChangePos + this.insertedCount);\r\n        }\r\n\r\n        /** Remove direction */\r\n        get removeDirection() {\r\n            if (!this.removedCount || this.insertedCount) return DIRECTION.NONE;\r\n\r\n            // align right if delete at right\r\n            return (this.oldSelection.end === this.cursorPos || this.oldSelection.start === this.cursorPos) &&\r\n            // if not range removed (event with backspace)\r\n            this.oldSelection.end === this.oldSelection.start ? DIRECTION.RIGHT : DIRECTION.LEFT;\r\n        }\r\n    }\r\n\r\n    /** Applies mask on element */\r\n    function IMask(el, opts) {\r\n        // currently available only for input-like elements\r\n        return new IMask.InputMask(el, opts);\r\n    }\r\n\r\n    // TODO can't use overloads here because of https://github.com/microsoft/TypeScript/issues/50754\r\n    // export function maskedClass(mask: string): typeof MaskedPattern;\r\n    // export function maskedClass(mask: DateConstructor): typeof MaskedDate;\r\n    // export function maskedClass(mask: NumberConstructor): typeof MaskedNumber;\r\n    // export function maskedClass(mask: Array<any> | ArrayConstructor): typeof MaskedDynamic;\r\n    // export function maskedClass(mask: MaskedDate): typeof MaskedDate;\r\n    // export function maskedClass(mask: MaskedNumber): typeof MaskedNumber;\r\n    // export function maskedClass(mask: MaskedEnum): typeof MaskedEnum;\r\n    // export function maskedClass(mask: MaskedRange): typeof MaskedRange;\r\n    // export function maskedClass(mask: MaskedRegExp): typeof MaskedRegExp;\r\n    // export function maskedClass(mask: MaskedFunction): typeof MaskedFunction;\r\n    // export function maskedClass(mask: MaskedPattern): typeof MaskedPattern;\r\n    // export function maskedClass(mask: MaskedDynamic): typeof MaskedDynamic;\r\n    // export function maskedClass(mask: Masked): typeof Masked;\r\n    // export function maskedClass(mask: typeof Masked): typeof Masked;\r\n    // export function maskedClass(mask: typeof MaskedDate): typeof MaskedDate;\r\n    // export function maskedClass(mask: typeof MaskedNumber): typeof MaskedNumber;\r\n    // export function maskedClass(mask: typeof MaskedEnum): typeof MaskedEnum;\r\n    // export function maskedClass(mask: typeof MaskedRange): typeof MaskedRange;\r\n    // export function maskedClass(mask: typeof MaskedRegExp): typeof MaskedRegExp;\r\n    // export function maskedClass(mask: typeof MaskedFunction): typeof MaskedFunction;\r\n    // export function maskedClass(mask: typeof MaskedPattern): typeof MaskedPattern;\r\n    // export function maskedClass(mask: typeof MaskedDynamic): typeof MaskedDynamic;\r\n    // export function maskedClass<Mask extends typeof Masked> (mask: Mask): Mask;\r\n    // export function maskedClass(mask: RegExp): typeof MaskedRegExp;\r\n    // export function maskedClass(mask: (value: string, ...args: any[]) => boolean): typeof MaskedFunction;\r\n\r\n    /** Get Masked class by mask type */\r\n    function maskedClass(mask) /* TODO */{\r\n        if (mask == null) throw new Error('mask property should be defined');\r\n        if (mask instanceof RegExp) return IMask.MaskedRegExp;\r\n        if (isString(mask)) return IMask.MaskedPattern;\r\n        if (mask === Date) return IMask.MaskedDate;\r\n        if (mask === Number) return IMask.MaskedNumber;\r\n        if (Array.isArray(mask) || mask === Array) return IMask.MaskedDynamic;\r\n        if (IMask.Masked && mask.prototype instanceof IMask.Masked) return mask;\r\n        if (IMask.Masked && mask instanceof IMask.Masked) return mask.constructor;\r\n        if (mask instanceof Function) return IMask.MaskedFunction;\r\n        console.warn('Mask not found for mask', mask); // eslint-disable-line no-console\r\n        return IMask.Masked;\r\n    }\r\n    function normalizeOpts(opts) {\r\n        if (!opts) throw new Error('Options in not defined');\r\n        if (IMask.Masked) {\r\n            if (opts.prototype instanceof IMask.Masked) return {\r\n                mask: opts\r\n            };\r\n\r\n            /*\r\n        handle cases like:\r\n        1) opts = Masked\r\n        2) opts = { mask: Masked, ...instanceOpts }\r\n      */\r\n            const {\r\n                mask = undefined,\r\n                ...instanceOpts\r\n            } = opts instanceof IMask.Masked ? {\r\n                mask: opts\r\n            } : isObject(opts) && opts.mask instanceof IMask.Masked ? opts : {};\r\n            if (mask) {\r\n                const _mask = mask.mask;\r\n                return {\r\n                    ...pick(mask, (_, k) => !k.startsWith('_')),\r\n                    mask: mask.constructor,\r\n                    _mask,\r\n                    ...instanceOpts\r\n                };\r\n            }\r\n        }\r\n        if (!isObject(opts)) return {\r\n            mask: opts\r\n        };\r\n        return {\r\n            ...opts\r\n        };\r\n    }\r\n\r\n    // TODO can't use overloads here because of https://github.com/microsoft/TypeScript/issues/50754\r\n\r\n    // From masked\r\n    // export default function createMask<Opts extends Masked, ReturnMasked=Opts> (opts: Opts): ReturnMasked;\r\n    // // From masked class\r\n    // export default function createMask<Opts extends MaskedOptions<typeof Masked>, ReturnMasked extends Masked=InstanceType<Opts['mask']>> (opts: Opts): ReturnMasked;\r\n    // export default function createMask<Opts extends MaskedOptions<typeof MaskedDate>, ReturnMasked extends MaskedDate=MaskedDate<Opts['parent']>> (opts: Opts): ReturnMasked;\r\n    // export default function createMask<Opts extends MaskedOptions<typeof MaskedNumber>, ReturnMasked extends MaskedNumber=MaskedNumber<Opts['parent']>> (opts: Opts): ReturnMasked;\r\n    // export default function createMask<Opts extends MaskedOptions<typeof MaskedEnum>, ReturnMasked extends MaskedEnum=MaskedEnum<Opts['parent']>> (opts: Opts): ReturnMasked;\r\n    // export default function createMask<Opts extends MaskedOptions<typeof MaskedRange>, ReturnMasked extends MaskedRange=MaskedRange<Opts['parent']>> (opts: Opts): ReturnMasked;\r\n    // export default function createMask<Opts extends MaskedOptions<typeof MaskedRegExp>, ReturnMasked extends MaskedRegExp=MaskedRegExp<Opts['parent']>> (opts: Opts): ReturnMasked;\r\n    // export default function createMask<Opts extends MaskedOptions<typeof MaskedFunction>, ReturnMasked extends MaskedFunction=MaskedFunction<Opts['parent']>> (opts: Opts): ReturnMasked;\r\n    // export default function createMask<Opts extends MaskedOptions<typeof MaskedPattern>, ReturnMasked extends MaskedPattern=MaskedPattern<Opts['parent']>> (opts: Opts): ReturnMasked;\r\n    // export default function createMask<Opts extends MaskedOptions<typeof MaskedDynamic>, ReturnMasked extends MaskedDynamic=MaskedDynamic<Opts['parent']>> (opts: Opts): ReturnMasked;\r\n    // // From mask opts\r\n    // export default function createMask<Opts extends MaskedOptions<Masked>, ReturnMasked=Opts extends MaskedOptions<infer M> ? M : never> (opts: Opts): ReturnMasked;\r\n    // export default function createMask<Opts extends MaskedNumberOptions, ReturnMasked extends MaskedNumber=MaskedNumber<Opts['parent']>> (opts: Opts): ReturnMasked;\r\n    // export default function createMask<Opts extends MaskedDateFactoryOptions, ReturnMasked extends MaskedDate=MaskedDate<Opts['parent']>> (opts: Opts): ReturnMasked;\r\n    // export default function createMask<Opts extends MaskedEnumOptions, ReturnMasked extends MaskedEnum=MaskedEnum<Opts['parent']>> (opts: Opts): ReturnMasked;\r\n    // export default function createMask<Opts extends MaskedRangeOptions, ReturnMasked extends MaskedRange=MaskedRange<Opts['parent']>> (opts: Opts): ReturnMasked;\r\n    // export default function createMask<Opts extends MaskedPatternOptions, ReturnMasked extends MaskedPattern=MaskedPattern<Opts['parent']>> (opts: Opts): ReturnMasked;\r\n    // export default function createMask<Opts extends MaskedDynamicOptions, ReturnMasked extends MaskedDynamic=MaskedDynamic<Opts['parent']>> (opts: Opts): ReturnMasked;\r\n    // export default function createMask<Opts extends MaskedOptions<RegExp>, ReturnMasked extends MaskedRegExp=MaskedRegExp<Opts['parent']>> (opts: Opts): ReturnMasked;\r\n    // export default function createMask<Opts extends MaskedOptions<Function>, ReturnMasked extends MaskedFunction=MaskedFunction<Opts['parent']>> (opts: Opts): ReturnMasked;\r\n\r\n    /** Creates new {@link Masked} depending on mask type */\r\n    function createMask(opts) {\r\n        if (IMask.Masked && opts instanceof IMask.Masked) return opts;\r\n        const nOpts = normalizeOpts(opts);\r\n        const MaskedClass = maskedClass(nOpts.mask);\r\n        if (!MaskedClass) throw new Error(\"Masked class is not found for provided mask \" + nOpts.mask + \", appropriate module needs to be imported manually before creating mask.\");\r\n        if (nOpts.mask === MaskedClass) delete nOpts.mask;\r\n        if (nOpts._mask) {\r\n            nOpts.mask = nOpts._mask;\r\n            delete nOpts._mask;\r\n        }\r\n        return new MaskedClass(nOpts);\r\n    }\r\n    IMask.createMask = createMask;\r\n\r\n    /**  Generic element API to use with mask */\r\n    class MaskElement {\r\n        /** */\r\n\r\n        /** */\r\n\r\n        /** */\r\n\r\n        /** Safely returns selection start */\r\n        get selectionStart() {\r\n            let start;\r\n            try {\r\n                start = this._unsafeSelectionStart;\r\n            } catch {}\r\n            return start != null ? start : this.value.length;\r\n        }\r\n\r\n        /** Safely returns selection end */\r\n        get selectionEnd() {\r\n            let end;\r\n            try {\r\n                end = this._unsafeSelectionEnd;\r\n            } catch {}\r\n            return end != null ? end : this.value.length;\r\n        }\r\n\r\n        /** Safely sets element selection */\r\n        select(start, end) {\r\n            if (start == null || end == null || start === this.selectionStart && end === this.selectionEnd) return;\r\n            try {\r\n                this._unsafeSelect(start, end);\r\n            } catch {}\r\n        }\r\n\r\n        /** */\r\n        get isActive() {\r\n            return false;\r\n        }\r\n        /** */\r\n\r\n        /** */\r\n\r\n        /** */\r\n    }\r\n    IMask.MaskElement = MaskElement;\r\n\r\n    const KEY_Z = 90;\r\n    const KEY_Y = 89;\r\n\r\n    /** Bridge between HTMLElement and {@link Masked} */\r\n    class HTMLMaskElement extends MaskElement {\r\n        /** HTMLElement to use mask on */\r\n\r\n        constructor(input) {\r\n            super();\r\n            this.input = input;\r\n            this._onKeydown = this._onKeydown.bind(this);\r\n            this._onInput = this._onInput.bind(this);\r\n            this._onBeforeinput = this._onBeforeinput.bind(this);\r\n            this._onCompositionEnd = this._onCompositionEnd.bind(this);\r\n        }\r\n        get rootElement() {\r\n            var _this$input$getRootNo, _this$input$getRootNo2, _this$input;\r\n            return (_this$input$getRootNo = (_this$input$getRootNo2 = (_this$input = this.input).getRootNode) == null ? void 0 : _this$input$getRootNo2.call(_this$input)) != null ? _this$input$getRootNo : document;\r\n        }\r\n\r\n        /** Is element in focus */\r\n        get isActive() {\r\n            return this.input === this.rootElement.activeElement;\r\n        }\r\n\r\n        /** Binds HTMLElement events to mask internal events */\r\n        bindEvents(handlers) {\r\n            this.input.addEventListener('keydown', this._onKeydown);\r\n            this.input.addEventListener('input', this._onInput);\r\n            this.input.addEventListener('beforeinput', this._onBeforeinput);\r\n            this.input.addEventListener('compositionend', this._onCompositionEnd);\r\n            this.input.addEventListener('drop', handlers.drop);\r\n            this.input.addEventListener('click', handlers.click);\r\n            this.input.addEventListener('focus', handlers.focus);\r\n            this.input.addEventListener('blur', handlers.commit);\r\n            this._handlers = handlers;\r\n        }\r\n        _onKeydown(e) {\r\n            if (this._handlers.redo && (e.keyCode === KEY_Z && e.shiftKey && (e.metaKey || e.ctrlKey) || e.keyCode === KEY_Y && e.ctrlKey)) {\r\n                e.preventDefault();\r\n                return this._handlers.redo(e);\r\n            }\r\n            if (this._handlers.undo && e.keyCode === KEY_Z && (e.metaKey || e.ctrlKey)) {\r\n                e.preventDefault();\r\n                return this._handlers.undo(e);\r\n            }\r\n            if (!e.isComposing) this._handlers.selectionChange(e);\r\n        }\r\n        _onBeforeinput(e) {\r\n            if (e.inputType === 'historyUndo' && this._handlers.undo) {\r\n                e.preventDefault();\r\n                return this._handlers.undo(e);\r\n            }\r\n            if (e.inputType === 'historyRedo' && this._handlers.redo) {\r\n                e.preventDefault();\r\n                return this._handlers.redo(e);\r\n            }\r\n        }\r\n        _onCompositionEnd(e) {\r\n            this._handlers.input(e);\r\n        }\r\n        _onInput(e) {\r\n            if (!e.isComposing) this._handlers.input(e);\r\n        }\r\n\r\n        /** Unbinds HTMLElement events to mask internal events */\r\n        unbindEvents() {\r\n            this.input.removeEventListener('keydown', this._onKeydown);\r\n            this.input.removeEventListener('input', this._onInput);\r\n            this.input.removeEventListener('beforeinput', this._onBeforeinput);\r\n            this.input.removeEventListener('compositionend', this._onCompositionEnd);\r\n            this.input.removeEventListener('drop', this._handlers.drop);\r\n            this.input.removeEventListener('click', this._handlers.click);\r\n            this.input.removeEventListener('focus', this._handlers.focus);\r\n            this.input.removeEventListener('blur', this._handlers.commit);\r\n            this._handlers = {};\r\n        }\r\n    }\r\n    IMask.HTMLMaskElement = HTMLMaskElement;\r\n\r\n    /** Bridge between InputElement and {@link Masked} */\r\n    class HTMLInputMaskElement extends HTMLMaskElement {\r\n        /** InputElement to use mask on */\r\n\r\n        constructor(input) {\r\n            super(input);\r\n            this.input = input;\r\n        }\r\n\r\n        /** Returns InputElement selection start */\r\n        get _unsafeSelectionStart() {\r\n            return this.input.selectionStart != null ? this.input.selectionStart : this.value.length;\r\n        }\r\n\r\n        /** Returns InputElement selection end */\r\n        get _unsafeSelectionEnd() {\r\n            return this.input.selectionEnd;\r\n        }\r\n\r\n        /** Sets InputElement selection */\r\n        _unsafeSelect(start, end) {\r\n            this.input.setSelectionRange(start, end);\r\n        }\r\n        get value() {\r\n            return this.input.value;\r\n        }\r\n        set value(value) {\r\n            this.input.value = value;\r\n        }\r\n    }\r\n    IMask.HTMLMaskElement = HTMLMaskElement;\r\n\r\n    class HTMLContenteditableMaskElement extends HTMLMaskElement {\r\n        /** Returns HTMLElement selection start */\r\n        get _unsafeSelectionStart() {\r\n            const root = this.rootElement;\r\n            const selection = root.getSelection && root.getSelection();\r\n            const anchorOffset = selection && selection.anchorOffset;\r\n            const focusOffset = selection && selection.focusOffset;\r\n            if (focusOffset == null || anchorOffset == null || anchorOffset < focusOffset) {\r\n                return anchorOffset;\r\n            }\r\n            return focusOffset;\r\n        }\r\n\r\n        /** Returns HTMLElement selection end */\r\n        get _unsafeSelectionEnd() {\r\n            const root = this.rootElement;\r\n            const selection = root.getSelection && root.getSelection();\r\n            const anchorOffset = selection && selection.anchorOffset;\r\n            const focusOffset = selection && selection.focusOffset;\r\n            if (focusOffset == null || anchorOffset == null || anchorOffset > focusOffset) {\r\n                return anchorOffset;\r\n            }\r\n            return focusOffset;\r\n        }\r\n\r\n        /** Sets HTMLElement selection */\r\n        _unsafeSelect(start, end) {\r\n            if (!this.rootElement.createRange) return;\r\n            const range = this.rootElement.createRange();\r\n            range.setStart(this.input.firstChild || this.input, start);\r\n            range.setEnd(this.input.lastChild || this.input, end);\r\n            const root = this.rootElement;\r\n            const selection = root.getSelection && root.getSelection();\r\n            if (selection) {\r\n                selection.removeAllRanges();\r\n                selection.addRange(range);\r\n            }\r\n        }\r\n\r\n        /** HTMLElement value */\r\n        get value() {\r\n            return this.input.textContent || '';\r\n        }\r\n        set value(value) {\r\n            this.input.textContent = value;\r\n        }\r\n    }\r\n    IMask.HTMLContenteditableMaskElement = HTMLContenteditableMaskElement;\r\n\r\n    class InputHistory {\r\n        constructor() {\r\n            this.states = [];\r\n            this.currentIndex = 0;\r\n        }\r\n        get currentState() {\r\n            return this.states[this.currentIndex];\r\n        }\r\n        get isEmpty() {\r\n            return this.states.length === 0;\r\n        }\r\n        push(state) {\r\n            // if current index points before the last element then remove the future\r\n            if (this.currentIndex < this.states.length - 1) this.states.length = this.currentIndex + 1;\r\n            this.states.push(state);\r\n            if (this.states.length > InputHistory.MAX_LENGTH) this.states.shift();\r\n            this.currentIndex = this.states.length - 1;\r\n        }\r\n        go(steps) {\r\n            this.currentIndex = Math.min(Math.max(this.currentIndex + steps, 0), this.states.length - 1);\r\n            return this.currentState;\r\n        }\r\n        undo() {\r\n            return this.go(-1);\r\n        }\r\n        redo() {\r\n            return this.go(+1);\r\n        }\r\n        clear() {\r\n            this.states.length = 0;\r\n            this.currentIndex = 0;\r\n        }\r\n    }\r\n    InputHistory.MAX_LENGTH = 100;\r\n\r\n    /** Listens to element events and controls changes between element and {@link Masked} */\r\n    class InputMask {\r\n        /**\r\n         View element\r\n         */\r\n\r\n        /** Internal {@link Masked} model */\r\n\r\n        constructor(el, opts) {\r\n            this.el = el instanceof MaskElement ? el : el.isContentEditable && el.tagName !== 'INPUT' && el.tagName !== 'TEXTAREA' ? new HTMLContenteditableMaskElement(el) : new HTMLInputMaskElement(el);\r\n            this.masked = createMask(opts);\r\n            this._listeners = {};\r\n            this._value = '';\r\n            this._unmaskedValue = '';\r\n            this._rawInputValue = '';\r\n            this.history = new InputHistory();\r\n            this._saveSelection = this._saveSelection.bind(this);\r\n            this._onInput = this._onInput.bind(this);\r\n            this._onChange = this._onChange.bind(this);\r\n            this._onDrop = this._onDrop.bind(this);\r\n            this._onFocus = this._onFocus.bind(this);\r\n            this._onClick = this._onClick.bind(this);\r\n            this._onUndo = this._onUndo.bind(this);\r\n            this._onRedo = this._onRedo.bind(this);\r\n            this.alignCursor = this.alignCursor.bind(this);\r\n            this.alignCursorFriendly = this.alignCursorFriendly.bind(this);\r\n            this._bindEvents();\r\n\r\n            // refresh\r\n            this.updateValue();\r\n            this._onChange();\r\n        }\r\n        maskEquals(mask) {\r\n            var _this$masked;\r\n            return mask == null || ((_this$masked = this.masked) == null ? void 0 : _this$masked.maskEquals(mask));\r\n        }\r\n\r\n        /** Masked */\r\n        get mask() {\r\n            return this.masked.mask;\r\n        }\r\n        set mask(mask) {\r\n            if (this.maskEquals(mask)) return;\r\n            if (!(mask instanceof IMask.Masked) && this.masked.constructor === maskedClass(mask)) {\r\n                // TODO \"any\" no idea\r\n                this.masked.updateOptions({\r\n                    mask\r\n                });\r\n                return;\r\n            }\r\n            const masked = mask instanceof IMask.Masked ? mask : createMask({\r\n                mask\r\n            });\r\n            masked.unmaskedValue = this.masked.unmaskedValue;\r\n            this.masked = masked;\r\n        }\r\n\r\n        /** Raw value */\r\n        get value() {\r\n            return this._value;\r\n        }\r\n        set value(str) {\r\n            if (this.value === str) return;\r\n            this.masked.value = str;\r\n            this.updateControl('auto');\r\n        }\r\n\r\n        /** Unmasked value */\r\n        get unmaskedValue() {\r\n            return this._unmaskedValue;\r\n        }\r\n        set unmaskedValue(str) {\r\n            if (this.unmaskedValue === str) return;\r\n            this.masked.unmaskedValue = str;\r\n            this.updateControl('auto');\r\n        }\r\n\r\n        /** Raw input value */\r\n        get rawInputValue() {\r\n            return this._rawInputValue;\r\n        }\r\n        set rawInputValue(str) {\r\n            if (this.rawInputValue === str) return;\r\n            this.masked.rawInputValue = str;\r\n            this.updateControl();\r\n            this.alignCursor();\r\n        }\r\n\r\n        /** Typed unmasked value */\r\n        get typedValue() {\r\n            return this.masked.typedValue;\r\n        }\r\n        set typedValue(val) {\r\n            if (this.masked.typedValueEquals(val)) return;\r\n            this.masked.typedValue = val;\r\n            this.updateControl('auto');\r\n        }\r\n\r\n        /** Display value */\r\n        get displayValue() {\r\n            return this.masked.displayValue;\r\n        }\r\n\r\n        /** Starts listening to element events */\r\n        _bindEvents() {\r\n            this.el.bindEvents({\r\n                selectionChange: this._saveSelection,\r\n                input: this._onInput,\r\n                drop: this._onDrop,\r\n                click: this._onClick,\r\n                focus: this._onFocus,\r\n                commit: this._onChange,\r\n                undo: this._onUndo,\r\n                redo: this._onRedo\r\n            });\r\n        }\r\n\r\n        /** Stops listening to element events */\r\n        _unbindEvents() {\r\n            if (this.el) this.el.unbindEvents();\r\n        }\r\n\r\n        /** Fires custom event */\r\n        _fireEvent(ev, e) {\r\n            const listeners = this._listeners[ev];\r\n            if (!listeners) return;\r\n            listeners.forEach(l => l(e));\r\n        }\r\n\r\n        /** Current selection start */\r\n        get selectionStart() {\r\n            return this._cursorChanging ? this._changingCursorPos : this.el.selectionStart;\r\n        }\r\n\r\n        /** Current cursor position */\r\n        get cursorPos() {\r\n            return this._cursorChanging ? this._changingCursorPos : this.el.selectionEnd;\r\n        }\r\n        set cursorPos(pos) {\r\n            if (!this.el || !this.el.isActive) return;\r\n            this.el.select(pos, pos);\r\n            this._saveSelection();\r\n        }\r\n\r\n        /** Stores current selection */\r\n        _saveSelection( /* ev */\r\n        ) {\r\n            if (this.displayValue !== this.el.value) {\r\n                console.warn('Element value was changed outside of mask. Syncronize mask using `mask.updateValue()` to work properly.'); // eslint-disable-line no-console\r\n            }\r\n            this._selection = {\r\n                start: this.selectionStart,\r\n                end: this.cursorPos\r\n            };\r\n        }\r\n\r\n        /** Syncronizes model value from view */\r\n        updateValue() {\r\n            this.masked.value = this.el.value;\r\n            this._value = this.masked.value;\r\n            this._unmaskedValue = this.masked.unmaskedValue;\r\n            this._rawInputValue = this.masked.rawInputValue;\r\n        }\r\n\r\n        /** Syncronizes view from model value, fires change events */\r\n        updateControl(cursorPos) {\r\n            const newUnmaskedValue = this.masked.unmaskedValue;\r\n            const newValue = this.masked.value;\r\n            const newRawInputValue = this.masked.rawInputValue;\r\n            const newDisplayValue = this.displayValue;\r\n            const isChanged = this.unmaskedValue !== newUnmaskedValue || this.value !== newValue || this._rawInputValue !== newRawInputValue;\r\n            this._unmaskedValue = newUnmaskedValue;\r\n            this._value = newValue;\r\n            this._rawInputValue = newRawInputValue;\r\n            if (this.el.value !== newDisplayValue) this.el.value = newDisplayValue;\r\n            if (cursorPos === 'auto') this.alignCursor();else if (cursorPos != null) this.cursorPos = cursorPos;\r\n            if (isChanged) this._fireChangeEvents();\r\n            if (!this._historyChanging && (isChanged || this.history.isEmpty)) this.history.push({\r\n                unmaskedValue: newUnmaskedValue,\r\n                selection: {\r\n                    start: this.selectionStart,\r\n                    end: this.cursorPos\r\n                }\r\n            });\r\n        }\r\n\r\n        /** Updates options with deep equal check, recreates {@link Masked} model if mask type changes */\r\n        updateOptions(opts) {\r\n            const {\r\n                mask,\r\n                ...restOpts\r\n            } = opts; // TODO types, yes, mask is optional\r\n\r\n            const updateMask = !this.maskEquals(mask);\r\n            const updateOpts = this.masked.optionsIsChanged(restOpts);\r\n            if (updateMask) this.mask = mask;\r\n            if (updateOpts) this.masked.updateOptions(restOpts); // TODO\r\n\r\n            if (updateMask || updateOpts) this.updateControl();\r\n        }\r\n\r\n        /** Updates cursor */\r\n        updateCursor(cursorPos) {\r\n            if (cursorPos == null) return;\r\n            this.cursorPos = cursorPos;\r\n\r\n            // also queue change cursor for mobile browsers\r\n            this._delayUpdateCursor(cursorPos);\r\n        }\r\n\r\n        /** Delays cursor update to support mobile browsers */\r\n        _delayUpdateCursor(cursorPos) {\r\n            this._abortUpdateCursor();\r\n            this._changingCursorPos = cursorPos;\r\n            this._cursorChanging = setTimeout(() => {\r\n                if (!this.el) return; // if was destroyed\r\n                this.cursorPos = this._changingCursorPos;\r\n                this._abortUpdateCursor();\r\n            }, 10);\r\n        }\r\n\r\n        /** Fires custom events */\r\n        _fireChangeEvents() {\r\n            this._fireEvent('accept', this._inputEvent);\r\n            if (this.masked.isComplete) this._fireEvent('complete', this._inputEvent);\r\n        }\r\n\r\n        /** Aborts delayed cursor update */\r\n        _abortUpdateCursor() {\r\n            if (this._cursorChanging) {\r\n                clearTimeout(this._cursorChanging);\r\n                delete this._cursorChanging;\r\n            }\r\n        }\r\n\r\n        /** Aligns cursor to nearest available position */\r\n        alignCursor() {\r\n            this.cursorPos = this.masked.nearestInputPos(this.masked.nearestInputPos(this.cursorPos, DIRECTION.LEFT));\r\n        }\r\n\r\n        /** Aligns cursor only if selection is empty */\r\n        alignCursorFriendly() {\r\n            if (this.selectionStart !== this.cursorPos) return; // skip if range is selected\r\n            this.alignCursor();\r\n        }\r\n\r\n        /** Adds listener on custom event */\r\n        on(ev, handler) {\r\n            if (!this._listeners[ev]) this._listeners[ev] = [];\r\n            this._listeners[ev].push(handler);\r\n            return this;\r\n        }\r\n\r\n        /** Removes custom event listener */\r\n        off(ev, handler) {\r\n            if (!this._listeners[ev]) return this;\r\n            if (!handler) {\r\n                delete this._listeners[ev];\r\n                return this;\r\n            }\r\n            const hIndex = this._listeners[ev].indexOf(handler);\r\n            if (hIndex >= 0) this._listeners[ev].splice(hIndex, 1);\r\n            return this;\r\n        }\r\n\r\n        /** Handles view input event */\r\n        _onInput(e) {\r\n            this._inputEvent = e;\r\n            this._abortUpdateCursor();\r\n            const details = new ActionDetails({\r\n                // new state\r\n                value: this.el.value,\r\n                cursorPos: this.cursorPos,\r\n                // old state\r\n                oldValue: this.displayValue,\r\n                oldSelection: this._selection\r\n            });\r\n            const oldRawValue = this.masked.rawInputValue;\r\n            const offset = this.masked.splice(details.startChangePos, details.removed.length, details.inserted, details.removeDirection, {\r\n                input: true,\r\n                raw: true\r\n            }).offset;\r\n\r\n            // force align in remove direction only if no input chars were removed\r\n            // otherwise we still need to align with NONE (to get out from fixed symbols for instance)\r\n            const removeDirection = oldRawValue === this.masked.rawInputValue ? details.removeDirection : DIRECTION.NONE;\r\n            let cursorPos = this.masked.nearestInputPos(details.startChangePos + offset, removeDirection);\r\n            if (removeDirection !== DIRECTION.NONE) cursorPos = this.masked.nearestInputPos(cursorPos, DIRECTION.NONE);\r\n            this.updateControl(cursorPos);\r\n            delete this._inputEvent;\r\n        }\r\n\r\n        /** Handles view change event and commits model value */\r\n        _onChange() {\r\n            if (this.displayValue !== this.el.value) this.updateValue();\r\n            this.masked.doCommit();\r\n            this.updateControl();\r\n            this._saveSelection();\r\n        }\r\n\r\n        /** Handles view drop event, prevents by default */\r\n        _onDrop(ev) {\r\n            ev.preventDefault();\r\n            ev.stopPropagation();\r\n        }\r\n\r\n        /** Restore last selection on focus */\r\n        _onFocus(ev) {\r\n            this.alignCursorFriendly();\r\n        }\r\n\r\n        /** Restore last selection on focus */\r\n        _onClick(ev) {\r\n            this.alignCursorFriendly();\r\n        }\r\n        _onUndo() {\r\n            this._applyHistoryState(this.history.undo());\r\n        }\r\n        _onRedo() {\r\n            this._applyHistoryState(this.history.redo());\r\n        }\r\n        _applyHistoryState(state) {\r\n            if (!state) return;\r\n            this._historyChanging = true;\r\n            this.unmaskedValue = state.unmaskedValue;\r\n            this.el.select(state.selection.start, state.selection.end);\r\n            this._saveSelection();\r\n            this._historyChanging = false;\r\n        }\r\n\r\n        /** Unbind view events and removes element reference */\r\n        destroy() {\r\n            this._unbindEvents();\r\n            this._listeners.length = 0;\r\n            delete this.el;\r\n        }\r\n    }\r\n    IMask.InputMask = InputMask;\r\n\r\n    /** Provides details of changing model value */\r\n    class ChangeDetails {\r\n        /** Inserted symbols */\r\n\r\n        /** Additional offset if any changes occurred before tail */\r\n\r\n        /** Raw inserted is used by dynamic mask */\r\n\r\n        /** Can skip chars */\r\n\r\n        static normalize(prep) {\r\n            return Array.isArray(prep) ? prep : [prep, new ChangeDetails()];\r\n        }\r\n        constructor(details) {\r\n            Object.assign(this, {\r\n                inserted: '',\r\n                rawInserted: '',\r\n                tailShift: 0,\r\n                skip: false\r\n            }, details);\r\n        }\r\n\r\n        /** Aggregate changes */\r\n        aggregate(details) {\r\n            this.inserted += details.inserted;\r\n            this.rawInserted += details.rawInserted;\r\n            this.tailShift += details.tailShift;\r\n            this.skip = this.skip || details.skip;\r\n            return this;\r\n        }\r\n\r\n        /** Total offset considering all changes */\r\n        get offset() {\r\n            return this.tailShift + this.inserted.length;\r\n        }\r\n        get consumed() {\r\n            return Boolean(this.rawInserted) || this.skip;\r\n        }\r\n        equals(details) {\r\n            return this.inserted === details.inserted && this.tailShift === details.tailShift && this.rawInserted === details.rawInserted && this.skip === details.skip;\r\n        }\r\n    }\r\n    IMask.ChangeDetails = ChangeDetails;\r\n\r\n    /** Provides details of continuous extracted tail */\r\n    class ContinuousTailDetails {\r\n        /** Tail value as string */\r\n\r\n        /** Tail start position */\r\n\r\n        /** Start position */\r\n\r\n        constructor(value, from, stop) {\r\n            if (value === void 0) {\r\n                value = '';\r\n            }\r\n            if (from === void 0) {\r\n                from = 0;\r\n            }\r\n            this.value = value;\r\n            this.from = from;\r\n            this.stop = stop;\r\n        }\r\n        toString() {\r\n            return this.value;\r\n        }\r\n        extend(tail) {\r\n            this.value += String(tail);\r\n        }\r\n        appendTo(masked) {\r\n            return masked.append(this.toString(), {\r\n                tail: true\r\n            }).aggregate(masked._appendPlaceholder());\r\n        }\r\n        get state() {\r\n            return {\r\n                value: this.value,\r\n                from: this.from,\r\n                stop: this.stop\r\n            };\r\n        }\r\n        set state(state) {\r\n            Object.assign(this, state);\r\n        }\r\n        unshift(beforePos) {\r\n            if (!this.value.length || beforePos != null && this.from >= beforePos) return '';\r\n            const shiftChar = this.value[0];\r\n            this.value = this.value.slice(1);\r\n            return shiftChar;\r\n        }\r\n        shift() {\r\n            if (!this.value.length) return '';\r\n            const shiftChar = this.value[this.value.length - 1];\r\n            this.value = this.value.slice(0, -1);\r\n            return shiftChar;\r\n        }\r\n    }\r\n\r\n    /** Append flags */\r\n\r\n    /** Extract flags */\r\n\r\n    // see https://github.com/microsoft/TypeScript/issues/6223\r\n\r\n    /** Provides common masking stuff */\r\n    class Masked {\r\n        /** */\r\n\r\n        /** */\r\n\r\n        /** Transforms value before mask processing */\r\n\r\n        /** Transforms each char before mask processing */\r\n\r\n        /** Validates if value is acceptable */\r\n\r\n        /** Does additional processing at the end of editing */\r\n\r\n        /** Format typed value to string */\r\n\r\n        /** Parse string to get typed value */\r\n\r\n        /** Enable characters overwriting */\r\n\r\n        /** */\r\n\r\n        /** */\r\n\r\n        /** */\r\n\r\n        /** */\r\n\r\n        constructor(opts) {\r\n            this._value = '';\r\n            this._update({\r\n                ...Masked.DEFAULTS,\r\n                ...opts\r\n            });\r\n            this._initialized = true;\r\n        }\r\n\r\n        /** Sets and applies new options */\r\n        updateOptions(opts) {\r\n            if (!this.optionsIsChanged(opts)) return;\r\n            this.withValueRefresh(this._update.bind(this, opts));\r\n        }\r\n\r\n        /** Sets new options */\r\n        _update(opts) {\r\n            Object.assign(this, opts);\r\n        }\r\n\r\n        /** Mask state */\r\n        get state() {\r\n            return {\r\n                _value: this.value,\r\n                _rawInputValue: this.rawInputValue\r\n            };\r\n        }\r\n        set state(state) {\r\n            this._value = state._value;\r\n        }\r\n\r\n        /** Resets value */\r\n        reset() {\r\n            this._value = '';\r\n        }\r\n        get value() {\r\n            return this._value;\r\n        }\r\n        set value(value) {\r\n            this.resolve(value, {\r\n                input: true\r\n            });\r\n        }\r\n\r\n        /** Resolve new value */\r\n        resolve(value, flags) {\r\n            if (flags === void 0) {\r\n                flags = {\r\n                    input: true\r\n                };\r\n            }\r\n            this.reset();\r\n            this.append(value, flags, '');\r\n            this.doCommit();\r\n        }\r\n        get unmaskedValue() {\r\n            return this.value;\r\n        }\r\n        set unmaskedValue(value) {\r\n            this.resolve(value, {});\r\n        }\r\n        get typedValue() {\r\n            return this.parse ? this.parse(this.value, this) : this.unmaskedValue;\r\n        }\r\n        set typedValue(value) {\r\n            if (this.format) {\r\n                this.value = this.format(value, this);\r\n            } else {\r\n                this.unmaskedValue = String(value);\r\n            }\r\n        }\r\n\r\n        /** Value that includes raw user input */\r\n        get rawInputValue() {\r\n            return this.extractInput(0, this.displayValue.length, {\r\n                raw: true\r\n            });\r\n        }\r\n        set rawInputValue(value) {\r\n            this.resolve(value, {\r\n                raw: true\r\n            });\r\n        }\r\n        get displayValue() {\r\n            return this.value;\r\n        }\r\n        get isComplete() {\r\n            return true;\r\n        }\r\n        get isFilled() {\r\n            return this.isComplete;\r\n        }\r\n\r\n        /** Finds nearest input position in direction */\r\n        nearestInputPos(cursorPos, direction) {\r\n            return cursorPos;\r\n        }\r\n        totalInputPositions(fromPos, toPos) {\r\n            if (fromPos === void 0) {\r\n                fromPos = 0;\r\n            }\r\n            if (toPos === void 0) {\r\n                toPos = this.displayValue.length;\r\n            }\r\n            return Math.min(this.displayValue.length, toPos - fromPos);\r\n        }\r\n\r\n        /** Extracts value in range considering flags */\r\n        extractInput(fromPos, toPos, flags) {\r\n            if (fromPos === void 0) {\r\n                fromPos = 0;\r\n            }\r\n            if (toPos === void 0) {\r\n                toPos = this.displayValue.length;\r\n            }\r\n            return this.displayValue.slice(fromPos, toPos);\r\n        }\r\n\r\n        /** Extracts tail in range */\r\n        extractTail(fromPos, toPos) {\r\n            if (fromPos === void 0) {\r\n                fromPos = 0;\r\n            }\r\n            if (toPos === void 0) {\r\n                toPos = this.displayValue.length;\r\n            }\r\n            return new ContinuousTailDetails(this.extractInput(fromPos, toPos), fromPos);\r\n        }\r\n\r\n        /** Appends tail */\r\n        appendTail(tail) {\r\n            if (isString(tail)) tail = new ContinuousTailDetails(String(tail));\r\n            return tail.appendTo(this);\r\n        }\r\n\r\n        /** Appends char */\r\n        _appendCharRaw(ch, flags) {\r\n            if (!ch) return new ChangeDetails();\r\n            this._value += ch;\r\n            return new ChangeDetails({\r\n                inserted: ch,\r\n                rawInserted: ch\r\n            });\r\n        }\r\n\r\n        /** Appends char */\r\n        _appendChar(ch, flags, checkTail) {\r\n            if (flags === void 0) {\r\n                flags = {};\r\n            }\r\n            const consistentState = this.state;\r\n            let details;\r\n            [ch, details] = this.doPrepareChar(ch, flags);\r\n            if (ch) {\r\n                details = details.aggregate(this._appendCharRaw(ch, flags));\r\n\r\n                // TODO handle `skip`?\r\n\r\n                // try `autofix` lookahead\r\n                if (!details.rawInserted && this.autofix === 'pad') {\r\n                    const noFixState = this.state;\r\n                    this.state = consistentState;\r\n                    let fixDetails = this.pad(flags);\r\n                    const chDetails = this._appendCharRaw(ch, flags);\r\n                    fixDetails = fixDetails.aggregate(chDetails);\r\n\r\n                    // if fix was applied or\r\n                    // if details are equal use skip restoring state optimization\r\n                    if (chDetails.rawInserted || fixDetails.equals(details)) {\r\n                        details = fixDetails;\r\n                    } else {\r\n                        this.state = noFixState;\r\n                    }\r\n                }\r\n            }\r\n            if (details.inserted) {\r\n                let consistentTail;\r\n                let appended = this.doValidate(flags) !== false;\r\n                if (appended && checkTail != null) {\r\n                    // validation ok, check tail\r\n                    const beforeTailState = this.state;\r\n                    if (this.overwrite === true) {\r\n                        consistentTail = checkTail.state;\r\n                        for (let i = 0; i < details.rawInserted.length; ++i) {\r\n                            checkTail.unshift(this.displayValue.length - details.tailShift);\r\n                        }\r\n                    }\r\n                    let tailDetails = this.appendTail(checkTail);\r\n                    appended = tailDetails.rawInserted.length === checkTail.toString().length;\r\n\r\n                    // not ok, try shift\r\n                    if (!(appended && tailDetails.inserted) && this.overwrite === 'shift') {\r\n                        this.state = beforeTailState;\r\n                        consistentTail = checkTail.state;\r\n                        for (let i = 0; i < details.rawInserted.length; ++i) {\r\n                            checkTail.shift();\r\n                        }\r\n                        tailDetails = this.appendTail(checkTail);\r\n                        appended = tailDetails.rawInserted.length === checkTail.toString().length;\r\n                    }\r\n\r\n                    // if ok, rollback state after tail\r\n                    if (appended && tailDetails.inserted) this.state = beforeTailState;\r\n                }\r\n\r\n                // revert all if something went wrong\r\n                if (!appended) {\r\n                    details = new ChangeDetails();\r\n                    this.state = consistentState;\r\n                    if (checkTail && consistentTail) checkTail.state = consistentTail;\r\n                }\r\n            }\r\n            return details;\r\n        }\r\n\r\n        /** Appends optional placeholder at the end */\r\n        _appendPlaceholder() {\r\n            return new ChangeDetails();\r\n        }\r\n\r\n        /** Appends optional eager placeholder at the end */\r\n        _appendEager() {\r\n            return new ChangeDetails();\r\n        }\r\n\r\n        /** Appends symbols considering flags */\r\n        append(str, flags, tail) {\r\n            if (!isString(str)) throw new Error('value should be string');\r\n            const checkTail = isString(tail) ? new ContinuousTailDetails(String(tail)) : tail;\r\n            if (flags != null && flags.tail) flags._beforeTailState = this.state;\r\n            let details;\r\n            [str, details] = this.doPrepare(str, flags);\r\n            for (let ci = 0; ci < str.length; ++ci) {\r\n                const d = this._appendChar(str[ci], flags, checkTail);\r\n                if (!d.rawInserted && !this.doSkipInvalid(str[ci], flags, checkTail)) break;\r\n                details.aggregate(d);\r\n            }\r\n            if ((this.eager === true || this.eager === 'append') && flags != null && flags.input && str) {\r\n                details.aggregate(this._appendEager());\r\n            }\r\n\r\n            // append tail but aggregate only tailShift\r\n            if (checkTail != null) {\r\n                details.tailShift += this.appendTail(checkTail).tailShift;\r\n                // TODO it's a good idea to clear state after appending ends\r\n                // but it causes bugs when one append calls another (when dynamic dispatch set rawInputValue)\r\n                // this._resetBeforeTailState();\r\n            }\r\n            return details;\r\n        }\r\n        remove(fromPos, toPos) {\r\n            if (fromPos === void 0) {\r\n                fromPos = 0;\r\n            }\r\n            if (toPos === void 0) {\r\n                toPos = this.displayValue.length;\r\n            }\r\n            this._value = this.displayValue.slice(0, fromPos) + this.displayValue.slice(toPos);\r\n            return new ChangeDetails();\r\n        }\r\n\r\n        /** Calls function and reapplies current value */\r\n        withValueRefresh(fn) {\r\n            if (this._refreshing || !this._initialized) return fn();\r\n            this._refreshing = true;\r\n            const rawInput = this.rawInputValue;\r\n            const value = this.value;\r\n            const ret = fn();\r\n            this.rawInputValue = rawInput;\r\n            // append lost trailing chars at the end\r\n            if (this.value && this.value !== value && value.indexOf(this.value) === 0) {\r\n                this.append(value.slice(this.displayValue.length), {}, '');\r\n                this.doCommit();\r\n            }\r\n            delete this._refreshing;\r\n            return ret;\r\n        }\r\n        runIsolated(fn) {\r\n            if (this._isolated || !this._initialized) return fn(this);\r\n            this._isolated = true;\r\n            const state = this.state;\r\n            const ret = fn(this);\r\n            this.state = state;\r\n            delete this._isolated;\r\n            return ret;\r\n        }\r\n        doSkipInvalid(ch, flags, checkTail) {\r\n            return Boolean(this.skipInvalid);\r\n        }\r\n\r\n        /** Prepares string before mask processing */\r\n        doPrepare(str, flags) {\r\n            if (flags === void 0) {\r\n                flags = {};\r\n            }\r\n            return ChangeDetails.normalize(this.prepare ? this.prepare(str, this, flags) : str);\r\n        }\r\n\r\n        /** Prepares each char before mask processing */\r\n        doPrepareChar(str, flags) {\r\n            if (flags === void 0) {\r\n                flags = {};\r\n            }\r\n            return ChangeDetails.normalize(this.prepareChar ? this.prepareChar(str, this, flags) : str);\r\n        }\r\n\r\n        /** Validates if value is acceptable */\r\n        doValidate(flags) {\r\n            return (!this.validate || this.validate(this.value, this, flags)) && (!this.parent || this.parent.doValidate(flags));\r\n        }\r\n\r\n        /** Does additional processing at the end of editing */\r\n        doCommit() {\r\n            if (this.commit) this.commit(this.value, this);\r\n        }\r\n        splice(start, deleteCount, inserted, removeDirection, flags) {\r\n            if (inserted === void 0) {\r\n                inserted = '';\r\n            }\r\n            if (removeDirection === void 0) {\r\n                removeDirection = DIRECTION.NONE;\r\n            }\r\n            if (flags === void 0) {\r\n                flags = {\r\n                    input: true\r\n                };\r\n            }\r\n            const tailPos = start + deleteCount;\r\n            const tail = this.extractTail(tailPos);\r\n            const eagerRemove = this.eager === true || this.eager === 'remove';\r\n            let oldRawValue;\r\n            if (eagerRemove) {\r\n                removeDirection = forceDirection(removeDirection);\r\n                oldRawValue = this.extractInput(0, tailPos, {\r\n                    raw: true\r\n                });\r\n            }\r\n            let startChangePos = start;\r\n            const details = new ChangeDetails();\r\n\r\n            // if it is just deletion without insertion\r\n            if (removeDirection !== DIRECTION.NONE) {\r\n                startChangePos = this.nearestInputPos(start, deleteCount > 1 && start !== 0 && !eagerRemove ? DIRECTION.NONE : removeDirection);\r\n\r\n                // adjust tailShift if start was aligned\r\n                details.tailShift = startChangePos - start;\r\n            }\r\n            details.aggregate(this.remove(startChangePos));\r\n            if (eagerRemove && removeDirection !== DIRECTION.NONE && oldRawValue === this.rawInputValue) {\r\n                if (removeDirection === DIRECTION.FORCE_LEFT) {\r\n                    let valLength;\r\n                    while (oldRawValue === this.rawInputValue && (valLength = this.displayValue.length)) {\r\n                        details.aggregate(new ChangeDetails({\r\n                            tailShift: -1\r\n                        })).aggregate(this.remove(valLength - 1));\r\n                    }\r\n                } else if (removeDirection === DIRECTION.FORCE_RIGHT) {\r\n                    tail.unshift();\r\n                }\r\n            }\r\n            return details.aggregate(this.append(inserted, flags, tail));\r\n        }\r\n        maskEquals(mask) {\r\n            return this.mask === mask;\r\n        }\r\n        optionsIsChanged(opts) {\r\n            return !objectIncludes(this, opts);\r\n        }\r\n        typedValueEquals(value) {\r\n            const tval = this.typedValue;\r\n            return value === tval || Masked.EMPTY_VALUES.includes(value) && Masked.EMPTY_VALUES.includes(tval) || (this.format ? this.format(value, this) === this.format(this.typedValue, this) : false);\r\n        }\r\n        pad(flags) {\r\n            return new ChangeDetails();\r\n        }\r\n    }\r\n    Masked.DEFAULTS = {\r\n        skipInvalid: true\r\n    };\r\n    Masked.EMPTY_VALUES = [undefined, null, ''];\r\n    IMask.Masked = Masked;\r\n\r\n    class ChunksTailDetails {\r\n        /** */\r\n\r\n        constructor(chunks, from) {\r\n            if (chunks === void 0) {\r\n                chunks = [];\r\n            }\r\n            if (from === void 0) {\r\n                from = 0;\r\n            }\r\n            this.chunks = chunks;\r\n            this.from = from;\r\n        }\r\n        toString() {\r\n            return this.chunks.map(String).join('');\r\n        }\r\n        extend(tailChunk) {\r\n            if (!String(tailChunk)) return;\r\n            tailChunk = isString(tailChunk) ? new ContinuousTailDetails(String(tailChunk)) : tailChunk;\r\n            const lastChunk = this.chunks[this.chunks.length - 1];\r\n            const extendLast = lastChunk && (\r\n                    // if stops are same or tail has no stop\r\n                    lastChunk.stop === tailChunk.stop || tailChunk.stop == null) &&\r\n                // if tail chunk goes just after last chunk\r\n                tailChunk.from === lastChunk.from + lastChunk.toString().length;\r\n            if (tailChunk instanceof ContinuousTailDetails) {\r\n                // check the ability to extend previous chunk\r\n                if (extendLast) {\r\n                    // extend previous chunk\r\n                    lastChunk.extend(tailChunk.toString());\r\n                } else {\r\n                    // append new chunk\r\n                    this.chunks.push(tailChunk);\r\n                }\r\n            } else if (tailChunk instanceof ChunksTailDetails) {\r\n                if (tailChunk.stop == null) {\r\n                    // unwrap floating chunks to parent, keeping `from` pos\r\n                    let firstTailChunk;\r\n                    while (tailChunk.chunks.length && tailChunk.chunks[0].stop == null) {\r\n                        firstTailChunk = tailChunk.chunks.shift(); // not possible to be `undefined` because length was checked above\r\n                        firstTailChunk.from += tailChunk.from;\r\n                        this.extend(firstTailChunk);\r\n                    }\r\n                }\r\n\r\n                // if tail chunk still has value\r\n                if (tailChunk.toString()) {\r\n                    // if chunks contains stops, then popup stop to container\r\n                    tailChunk.stop = tailChunk.blockIndex;\r\n                    this.chunks.push(tailChunk);\r\n                }\r\n            }\r\n        }\r\n        appendTo(masked) {\r\n            if (!(masked instanceof IMask.MaskedPattern)) {\r\n                const tail = new ContinuousTailDetails(this.toString());\r\n                return tail.appendTo(masked);\r\n            }\r\n            const details = new ChangeDetails();\r\n            for (let ci = 0; ci < this.chunks.length; ++ci) {\r\n                const chunk = this.chunks[ci];\r\n                const lastBlockIter = masked._mapPosToBlock(masked.displayValue.length);\r\n                const stop = chunk.stop;\r\n                let chunkBlock;\r\n                if (stop != null && (\r\n                    // if block not found or stop is behind lastBlock\r\n                    !lastBlockIter || lastBlockIter.index <= stop)) {\r\n                    if (chunk instanceof ChunksTailDetails ||\r\n                        // for continuous block also check if stop is exist\r\n                        masked._stops.indexOf(stop) >= 0) {\r\n                        details.aggregate(masked._appendPlaceholder(stop));\r\n                    }\r\n                    chunkBlock = chunk instanceof ChunksTailDetails && masked._blocks[stop];\r\n                }\r\n                if (chunkBlock) {\r\n                    const tailDetails = chunkBlock.appendTail(chunk);\r\n                    details.aggregate(tailDetails);\r\n\r\n                    // get not inserted chars\r\n                    const remainChars = chunk.toString().slice(tailDetails.rawInserted.length);\r\n                    if (remainChars) details.aggregate(masked.append(remainChars, {\r\n                        tail: true\r\n                    }));\r\n                } else {\r\n                    details.aggregate(masked.append(chunk.toString(), {\r\n                        tail: true\r\n                    }));\r\n                }\r\n            }\r\n            return details;\r\n        }\r\n        get state() {\r\n            return {\r\n                chunks: this.chunks.map(c => c.state),\r\n                from: this.from,\r\n                stop: this.stop,\r\n                blockIndex: this.blockIndex\r\n            };\r\n        }\r\n        set state(state) {\r\n            const {\r\n                chunks,\r\n                ...props\r\n            } = state;\r\n            Object.assign(this, props);\r\n            this.chunks = chunks.map(cstate => {\r\n                const chunk = \"chunks\" in cstate ? new ChunksTailDetails() : new ContinuousTailDetails();\r\n                chunk.state = cstate;\r\n                return chunk;\r\n            });\r\n        }\r\n        unshift(beforePos) {\r\n            if (!this.chunks.length || beforePos != null && this.from >= beforePos) return '';\r\n            const chunkShiftPos = beforePos != null ? beforePos - this.from : beforePos;\r\n            let ci = 0;\r\n            while (ci < this.chunks.length) {\r\n                const chunk = this.chunks[ci];\r\n                const shiftChar = chunk.unshift(chunkShiftPos);\r\n                if (chunk.toString()) {\r\n                    // chunk still contains value\r\n                    // but not shifted - means no more available chars to shift\r\n                    if (!shiftChar) break;\r\n                    ++ci;\r\n                } else {\r\n                    // clean if chunk has no value\r\n                    this.chunks.splice(ci, 1);\r\n                }\r\n                if (shiftChar) return shiftChar;\r\n            }\r\n            return '';\r\n        }\r\n        shift() {\r\n            if (!this.chunks.length) return '';\r\n            let ci = this.chunks.length - 1;\r\n            while (0 <= ci) {\r\n                const chunk = this.chunks[ci];\r\n                const shiftChar = chunk.shift();\r\n                if (chunk.toString()) {\r\n                    // chunk still contains value\r\n                    // but not shifted - means no more available chars to shift\r\n                    if (!shiftChar) break;\r\n                    --ci;\r\n                } else {\r\n                    // clean if chunk has no value\r\n                    this.chunks.splice(ci, 1);\r\n                }\r\n                if (shiftChar) return shiftChar;\r\n            }\r\n            return '';\r\n        }\r\n    }\r\n\r\n    class PatternCursor {\r\n        constructor(masked, pos) {\r\n            this.masked = masked;\r\n            this._log = [];\r\n            const {\r\n                offset,\r\n                index\r\n            } = masked._mapPosToBlock(pos) || (pos < 0 ?\r\n                // first\r\n                {\r\n                    index: 0,\r\n                    offset: 0\r\n                } :\r\n                // last\r\n                {\r\n                    index: this.masked._blocks.length,\r\n                    offset: 0\r\n                });\r\n            this.offset = offset;\r\n            this.index = index;\r\n            this.ok = false;\r\n        }\r\n        get block() {\r\n            return this.masked._blocks[this.index];\r\n        }\r\n        get pos() {\r\n            return this.masked._blockStartPos(this.index) + this.offset;\r\n        }\r\n        get state() {\r\n            return {\r\n                index: this.index,\r\n                offset: this.offset,\r\n                ok: this.ok\r\n            };\r\n        }\r\n        set state(s) {\r\n            Object.assign(this, s);\r\n        }\r\n        pushState() {\r\n            this._log.push(this.state);\r\n        }\r\n        popState() {\r\n            const s = this._log.pop();\r\n            if (s) this.state = s;\r\n            return s;\r\n        }\r\n        bindBlock() {\r\n            if (this.block) return;\r\n            if (this.index < 0) {\r\n                this.index = 0;\r\n                this.offset = 0;\r\n            }\r\n            if (this.index >= this.masked._blocks.length) {\r\n                this.index = this.masked._blocks.length - 1;\r\n                this.offset = this.block.displayValue.length; // TODO this is stupid type error, `block` depends on index that was changed above\r\n            }\r\n        }\r\n        _pushLeft(fn) {\r\n            this.pushState();\r\n            for (this.bindBlock(); 0 <= this.index; --this.index, this.offset = ((_this$block = this.block) == null ? void 0 : _this$block.displayValue.length) || 0) {\r\n                var _this$block;\r\n                if (fn()) return this.ok = true;\r\n            }\r\n            return this.ok = false;\r\n        }\r\n        _pushRight(fn) {\r\n            this.pushState();\r\n            for (this.bindBlock(); this.index < this.masked._blocks.length; ++this.index, this.offset = 0) {\r\n                if (fn()) return this.ok = true;\r\n            }\r\n            return this.ok = false;\r\n        }\r\n        pushLeftBeforeFilled() {\r\n            return this._pushLeft(() => {\r\n                if (this.block.isFixed || !this.block.value) return;\r\n                this.offset = this.block.nearestInputPos(this.offset, DIRECTION.FORCE_LEFT);\r\n                if (this.offset !== 0) return true;\r\n            });\r\n        }\r\n        pushLeftBeforeInput() {\r\n            // cases:\r\n            // filled input: 00|\r\n            // optional empty input: 00[]|\r\n            // nested block: XX<[]>|\r\n            return this._pushLeft(() => {\r\n                if (this.block.isFixed) return;\r\n                this.offset = this.block.nearestInputPos(this.offset, DIRECTION.LEFT);\r\n                return true;\r\n            });\r\n        }\r\n        pushLeftBeforeRequired() {\r\n            return this._pushLeft(() => {\r\n                if (this.block.isFixed || this.block.isOptional && !this.block.value) return;\r\n                this.offset = this.block.nearestInputPos(this.offset, DIRECTION.LEFT);\r\n                return true;\r\n            });\r\n        }\r\n        pushRightBeforeFilled() {\r\n            return this._pushRight(() => {\r\n                if (this.block.isFixed || !this.block.value) return;\r\n                this.offset = this.block.nearestInputPos(this.offset, DIRECTION.FORCE_RIGHT);\r\n                if (this.offset !== this.block.value.length) return true;\r\n            });\r\n        }\r\n        pushRightBeforeInput() {\r\n            return this._pushRight(() => {\r\n                if (this.block.isFixed) return;\r\n\r\n                // const o = this.offset;\r\n                this.offset = this.block.nearestInputPos(this.offset, DIRECTION.NONE);\r\n                // HACK cases like (STILL DOES NOT WORK FOR NESTED)\r\n                // aa|X\r\n                // aa<X|[]>X_    - this will not work\r\n                // if (o && o === this.offset && this.block instanceof PatternInputDefinition) continue;\r\n                return true;\r\n            });\r\n        }\r\n        pushRightBeforeRequired() {\r\n            return this._pushRight(() => {\r\n                if (this.block.isFixed || this.block.isOptional && !this.block.value) return;\r\n\r\n                // TODO check |[*]XX_\r\n                this.offset = this.block.nearestInputPos(this.offset, DIRECTION.NONE);\r\n                return true;\r\n            });\r\n        }\r\n    }\r\n\r\n    class PatternFixedDefinition {\r\n        /** */\r\n\r\n        /** */\r\n\r\n        /** */\r\n\r\n        /** */\r\n\r\n        /** */\r\n\r\n        /** */\r\n\r\n        constructor(opts) {\r\n            Object.assign(this, opts);\r\n            this._value = '';\r\n            this.isFixed = true;\r\n        }\r\n        get value() {\r\n            return this._value;\r\n        }\r\n        get unmaskedValue() {\r\n            return this.isUnmasking ? this.value : '';\r\n        }\r\n        get rawInputValue() {\r\n            return this._isRawInput ? this.value : '';\r\n        }\r\n        get displayValue() {\r\n            return this.value;\r\n        }\r\n        reset() {\r\n            this._isRawInput = false;\r\n            this._value = '';\r\n        }\r\n        remove(fromPos, toPos) {\r\n            if (fromPos === void 0) {\r\n                fromPos = 0;\r\n            }\r\n            if (toPos === void 0) {\r\n                toPos = this._value.length;\r\n            }\r\n            this._value = this._value.slice(0, fromPos) + this._value.slice(toPos);\r\n            if (!this._value) this._isRawInput = false;\r\n            return new ChangeDetails();\r\n        }\r\n        nearestInputPos(cursorPos, direction) {\r\n            if (direction === void 0) {\r\n                direction = DIRECTION.NONE;\r\n            }\r\n            const minPos = 0;\r\n            const maxPos = this._value.length;\r\n            switch (direction) {\r\n                case DIRECTION.LEFT:\r\n                case DIRECTION.FORCE_LEFT:\r\n                    return minPos;\r\n                case DIRECTION.NONE:\r\n                case DIRECTION.RIGHT:\r\n                case DIRECTION.FORCE_RIGHT:\r\n                default:\r\n                    return maxPos;\r\n            }\r\n        }\r\n        totalInputPositions(fromPos, toPos) {\r\n            if (fromPos === void 0) {\r\n                fromPos = 0;\r\n            }\r\n            if (toPos === void 0) {\r\n                toPos = this._value.length;\r\n            }\r\n            return this._isRawInput ? toPos - fromPos : 0;\r\n        }\r\n        extractInput(fromPos, toPos, flags) {\r\n            if (fromPos === void 0) {\r\n                fromPos = 0;\r\n            }\r\n            if (toPos === void 0) {\r\n                toPos = this._value.length;\r\n            }\r\n            if (flags === void 0) {\r\n                flags = {};\r\n            }\r\n            return flags.raw && this._isRawInput && this._value.slice(fromPos, toPos) || '';\r\n        }\r\n        get isComplete() {\r\n            return true;\r\n        }\r\n        get isFilled() {\r\n            return Boolean(this._value);\r\n        }\r\n        _appendChar(ch, flags) {\r\n            if (flags === void 0) {\r\n                flags = {};\r\n            }\r\n            if (this.isFilled) return new ChangeDetails();\r\n            const appendEager = this.eager === true || this.eager === 'append';\r\n            const appended = this.char === ch;\r\n            const isResolved = appended && (this.isUnmasking || flags.input || flags.raw) && (!flags.raw || !appendEager) && !flags.tail;\r\n            const details = new ChangeDetails({\r\n                inserted: this.char,\r\n                rawInserted: isResolved ? this.char : ''\r\n            });\r\n            this._value = this.char;\r\n            this._isRawInput = isResolved && (flags.raw || flags.input);\r\n            return details;\r\n        }\r\n        _appendEager() {\r\n            return this._appendChar(this.char, {\r\n                tail: true\r\n            });\r\n        }\r\n        _appendPlaceholder() {\r\n            const details = new ChangeDetails();\r\n            if (this.isFilled) return details;\r\n            this._value = details.inserted = this.char;\r\n            return details;\r\n        }\r\n        extractTail() {\r\n            return new ContinuousTailDetails('');\r\n        }\r\n        appendTail(tail) {\r\n            if (isString(tail)) tail = new ContinuousTailDetails(String(tail));\r\n            return tail.appendTo(this);\r\n        }\r\n        append(str, flags, tail) {\r\n            const details = this._appendChar(str[0], flags);\r\n            if (tail != null) {\r\n                details.tailShift += this.appendTail(tail).tailShift;\r\n            }\r\n            return details;\r\n        }\r\n        doCommit() {}\r\n        get state() {\r\n            return {\r\n                _value: this._value,\r\n                _rawInputValue: this.rawInputValue\r\n            };\r\n        }\r\n        set state(state) {\r\n            this._value = state._value;\r\n            this._isRawInput = Boolean(state._rawInputValue);\r\n        }\r\n        pad(flags) {\r\n            return this._appendPlaceholder();\r\n        }\r\n    }\r\n\r\n    class PatternInputDefinition {\r\n        /** */\r\n\r\n        /** */\r\n\r\n        /** */\r\n\r\n        /** */\r\n\r\n        /** */\r\n\r\n        /** */\r\n\r\n        /** */\r\n\r\n        /** */\r\n\r\n        constructor(opts) {\r\n            const {\r\n                parent,\r\n                isOptional,\r\n                placeholderChar,\r\n                displayChar,\r\n                lazy,\r\n                eager,\r\n                ...maskOpts\r\n            } = opts;\r\n            this.masked = createMask(maskOpts);\r\n            Object.assign(this, {\r\n                parent,\r\n                isOptional,\r\n                placeholderChar,\r\n                displayChar,\r\n                lazy,\r\n                eager\r\n            });\r\n        }\r\n        reset() {\r\n            this.isFilled = false;\r\n            this.masked.reset();\r\n        }\r\n        remove(fromPos, toPos) {\r\n            if (fromPos === void 0) {\r\n                fromPos = 0;\r\n            }\r\n            if (toPos === void 0) {\r\n                toPos = this.value.length;\r\n            }\r\n            if (fromPos === 0 && toPos >= 1) {\r\n                this.isFilled = false;\r\n                return this.masked.remove(fromPos, toPos);\r\n            }\r\n            return new ChangeDetails();\r\n        }\r\n        get value() {\r\n            return this.masked.value || (this.isFilled && !this.isOptional ? this.placeholderChar : '');\r\n        }\r\n        get unmaskedValue() {\r\n            return this.masked.unmaskedValue;\r\n        }\r\n        get rawInputValue() {\r\n            return this.masked.rawInputValue;\r\n        }\r\n        get displayValue() {\r\n            return this.masked.value && this.displayChar || this.value;\r\n        }\r\n        get isComplete() {\r\n            return Boolean(this.masked.value) || this.isOptional;\r\n        }\r\n        _appendChar(ch, flags) {\r\n            if (flags === void 0) {\r\n                flags = {};\r\n            }\r\n            if (this.isFilled) return new ChangeDetails();\r\n            const state = this.masked.state;\r\n            // simulate input\r\n            let details = this.masked._appendChar(ch, this.currentMaskFlags(flags));\r\n            if (details.inserted && this.doValidate(flags) === false) {\r\n                details = new ChangeDetails();\r\n                this.masked.state = state;\r\n            }\r\n            if (!details.inserted && !this.isOptional && !this.lazy && !flags.input) {\r\n                details.inserted = this.placeholderChar;\r\n            }\r\n            details.skip = !details.inserted && !this.isOptional;\r\n            this.isFilled = Boolean(details.inserted);\r\n            return details;\r\n        }\r\n        append(str, flags, tail) {\r\n            // TODO probably should be done via _appendChar\r\n            return this.masked.append(str, this.currentMaskFlags(flags), tail);\r\n        }\r\n        _appendPlaceholder() {\r\n            if (this.isFilled || this.isOptional) return new ChangeDetails();\r\n            this.isFilled = true;\r\n            return new ChangeDetails({\r\n                inserted: this.placeholderChar\r\n            });\r\n        }\r\n        _appendEager() {\r\n            return new ChangeDetails();\r\n        }\r\n        extractTail(fromPos, toPos) {\r\n            return this.masked.extractTail(fromPos, toPos);\r\n        }\r\n        appendTail(tail) {\r\n            return this.masked.appendTail(tail);\r\n        }\r\n        extractInput(fromPos, toPos, flags) {\r\n            if (fromPos === void 0) {\r\n                fromPos = 0;\r\n            }\r\n            if (toPos === void 0) {\r\n                toPos = this.value.length;\r\n            }\r\n            return this.masked.extractInput(fromPos, toPos, flags);\r\n        }\r\n        nearestInputPos(cursorPos, direction) {\r\n            if (direction === void 0) {\r\n                direction = DIRECTION.NONE;\r\n            }\r\n            const minPos = 0;\r\n            const maxPos = this.value.length;\r\n            const boundPos = Math.min(Math.max(cursorPos, minPos), maxPos);\r\n            switch (direction) {\r\n                case DIRECTION.LEFT:\r\n                case DIRECTION.FORCE_LEFT:\r\n                    return this.isComplete ? boundPos : minPos;\r\n                case DIRECTION.RIGHT:\r\n                case DIRECTION.FORCE_RIGHT:\r\n                    return this.isComplete ? boundPos : maxPos;\r\n                case DIRECTION.NONE:\r\n                default:\r\n                    return boundPos;\r\n            }\r\n        }\r\n        totalInputPositions(fromPos, toPos) {\r\n            if (fromPos === void 0) {\r\n                fromPos = 0;\r\n            }\r\n            if (toPos === void 0) {\r\n                toPos = this.value.length;\r\n            }\r\n            return this.value.slice(fromPos, toPos).length;\r\n        }\r\n        doValidate(flags) {\r\n            return this.masked.doValidate(this.currentMaskFlags(flags)) && (!this.parent || this.parent.doValidate(this.currentMaskFlags(flags)));\r\n        }\r\n        doCommit() {\r\n            this.masked.doCommit();\r\n        }\r\n        get state() {\r\n            return {\r\n                _value: this.value,\r\n                _rawInputValue: this.rawInputValue,\r\n                masked: this.masked.state,\r\n                isFilled: this.isFilled\r\n            };\r\n        }\r\n        set state(state) {\r\n            this.masked.state = state.masked;\r\n            this.isFilled = state.isFilled;\r\n        }\r\n        currentMaskFlags(flags) {\r\n            var _flags$_beforeTailSta;\r\n            return {\r\n                ...flags,\r\n                _beforeTailState: (flags == null || (_flags$_beforeTailSta = flags._beforeTailState) == null ? void 0 : _flags$_beforeTailSta.masked) || (flags == null ? void 0 : flags._beforeTailState)\r\n            };\r\n        }\r\n        pad(flags) {\r\n            return new ChangeDetails();\r\n        }\r\n    }\r\n    PatternInputDefinition.DEFAULT_DEFINITIONS = {\r\n        '0': /\\d/,\r\n        'a': /[\\u0041-\\u005A\\u0061-\\u007A\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0\\u08A2-\\u08AC\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA697\\uA6A0-\\uA6E5\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]/,\r\n        // http://stackoverflow.com/a/22075070\r\n        '*': /./\r\n    };\r\n\r\n    /** Masking by RegExp */\r\n    class MaskedRegExp extends Masked {\r\n        /** */\r\n\r\n        /** Enable characters overwriting */\r\n\r\n        /** */\r\n\r\n        /** */\r\n\r\n        /** */\r\n\r\n        updateOptions(opts) {\r\n            super.updateOptions(opts);\r\n        }\r\n        _update(opts) {\r\n            const mask = opts.mask;\r\n            if (mask) opts.validate = value => value.search(mask) >= 0;\r\n            super._update(opts);\r\n        }\r\n    }\r\n    IMask.MaskedRegExp = MaskedRegExp;\r\n\r\n    /** Pattern mask */\r\n    class MaskedPattern extends Masked {\r\n        /** */\r\n\r\n        /** */\r\n\r\n        /** Single char for empty input */\r\n\r\n        /** Single char for filled input */\r\n\r\n        /** Show placeholder only when needed */\r\n\r\n        /** Enable characters overwriting */\r\n\r\n        /** */\r\n\r\n        /** */\r\n\r\n        /** */\r\n\r\n        constructor(opts) {\r\n            super({\r\n                ...MaskedPattern.DEFAULTS,\r\n                ...opts,\r\n                definitions: Object.assign({}, PatternInputDefinition.DEFAULT_DEFINITIONS, opts == null ? void 0 : opts.definitions)\r\n            });\r\n        }\r\n        updateOptions(opts) {\r\n            super.updateOptions(opts);\r\n        }\r\n        _update(opts) {\r\n            opts.definitions = Object.assign({}, this.definitions, opts.definitions);\r\n            super._update(opts);\r\n            this._rebuildMask();\r\n        }\r\n        _rebuildMask() {\r\n            const defs = this.definitions;\r\n            this._blocks = [];\r\n            this.exposeBlock = undefined;\r\n            this._stops = [];\r\n            this._maskedBlocks = {};\r\n            const pattern = this.mask;\r\n            if (!pattern || !defs) return;\r\n            let unmaskingBlock = false;\r\n            let optionalBlock = false;\r\n            for (let i = 0; i < pattern.length; ++i) {\r\n                if (this.blocks) {\r\n                    const p = pattern.slice(i);\r\n                    const bNames = Object.keys(this.blocks).filter(bName => p.indexOf(bName) === 0);\r\n                    // order by key length\r\n                    bNames.sort((a, b) => b.length - a.length);\r\n                    // use block name with max length\r\n                    const bName = bNames[0];\r\n                    if (bName) {\r\n                        const {\r\n                            expose,\r\n                            repeat,\r\n                            ...bOpts\r\n                        } = normalizeOpts(this.blocks[bName]); // TODO type Opts<Arg & Extra>\r\n                        const blockOpts = {\r\n                            lazy: this.lazy,\r\n                            eager: this.eager,\r\n                            placeholderChar: this.placeholderChar,\r\n                            displayChar: this.displayChar,\r\n                            overwrite: this.overwrite,\r\n                            autofix: this.autofix,\r\n                            ...bOpts,\r\n                            repeat,\r\n                            parent: this\r\n                        };\r\n                        const maskedBlock = repeat != null ? new IMask.RepeatBlock(blockOpts /* TODO */) : createMask(blockOpts);\r\n                        if (maskedBlock) {\r\n                            this._blocks.push(maskedBlock);\r\n                            if (expose) this.exposeBlock = maskedBlock;\r\n\r\n                            // store block index\r\n                            if (!this._maskedBlocks[bName]) this._maskedBlocks[bName] = [];\r\n                            this._maskedBlocks[bName].push(this._blocks.length - 1);\r\n                        }\r\n                        i += bName.length - 1;\r\n                        continue;\r\n                    }\r\n                }\r\n                let char = pattern[i];\r\n                let isInput = (char in defs);\r\n                if (char === MaskedPattern.STOP_CHAR) {\r\n                    this._stops.push(this._blocks.length);\r\n                    continue;\r\n                }\r\n                if (char === '{' || char === '}') {\r\n                    unmaskingBlock = !unmaskingBlock;\r\n                    continue;\r\n                }\r\n                if (char === '[' || char === ']') {\r\n                    optionalBlock = !optionalBlock;\r\n                    continue;\r\n                }\r\n                if (char === MaskedPattern.ESCAPE_CHAR) {\r\n                    ++i;\r\n                    char = pattern[i];\r\n                    if (!char) break;\r\n                    isInput = false;\r\n                }\r\n                const def = isInput ? new PatternInputDefinition({\r\n                    isOptional: optionalBlock,\r\n                    lazy: this.lazy,\r\n                    eager: this.eager,\r\n                    placeholderChar: this.placeholderChar,\r\n                    displayChar: this.displayChar,\r\n                    ...normalizeOpts(defs[char]),\r\n                    parent: this\r\n                }) : new PatternFixedDefinition({\r\n                    char,\r\n                    eager: this.eager,\r\n                    isUnmasking: unmaskingBlock\r\n                });\r\n                this._blocks.push(def);\r\n            }\r\n        }\r\n        get state() {\r\n            return {\r\n                ...super.state,\r\n                _blocks: this._blocks.map(b => b.state)\r\n            };\r\n        }\r\n        set state(state) {\r\n            if (!state) {\r\n                this.reset();\r\n                return;\r\n            }\r\n            const {\r\n                _blocks,\r\n                ...maskedState\r\n            } = state;\r\n            this._blocks.forEach((b, bi) => b.state = _blocks[bi]);\r\n            super.state = maskedState;\r\n        }\r\n        reset() {\r\n            super.reset();\r\n            this._blocks.forEach(b => b.reset());\r\n        }\r\n        get isComplete() {\r\n            return this.exposeBlock ? this.exposeBlock.isComplete : this._blocks.every(b => b.isComplete);\r\n        }\r\n        get isFilled() {\r\n            return this._blocks.every(b => b.isFilled);\r\n        }\r\n        get isFixed() {\r\n            return this._blocks.every(b => b.isFixed);\r\n        }\r\n        get isOptional() {\r\n            return this._blocks.every(b => b.isOptional);\r\n        }\r\n        doCommit() {\r\n            this._blocks.forEach(b => b.doCommit());\r\n            super.doCommit();\r\n        }\r\n        get unmaskedValue() {\r\n            return this.exposeBlock ? this.exposeBlock.unmaskedValue : this._blocks.reduce((str, b) => str += b.unmaskedValue, '');\r\n        }\r\n        set unmaskedValue(unmaskedValue) {\r\n            if (this.exposeBlock) {\r\n                const tail = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);\r\n                this.exposeBlock.unmaskedValue = unmaskedValue;\r\n                this.appendTail(tail);\r\n                this.doCommit();\r\n            } else super.unmaskedValue = unmaskedValue;\r\n        }\r\n        get value() {\r\n            return this.exposeBlock ? this.exposeBlock.value :\r\n                // TODO return _value when not in change?\r\n                this._blocks.reduce((str, b) => str += b.value, '');\r\n        }\r\n        set value(value) {\r\n            if (this.exposeBlock) {\r\n                const tail = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);\r\n                this.exposeBlock.value = value;\r\n                this.appendTail(tail);\r\n                this.doCommit();\r\n            } else super.value = value;\r\n        }\r\n        get typedValue() {\r\n            return this.exposeBlock ? this.exposeBlock.typedValue : super.typedValue;\r\n        }\r\n        set typedValue(value) {\r\n            if (this.exposeBlock) {\r\n                const tail = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);\r\n                this.exposeBlock.typedValue = value;\r\n                this.appendTail(tail);\r\n                this.doCommit();\r\n            } else super.typedValue = value;\r\n        }\r\n        get displayValue() {\r\n            return this._blocks.reduce((str, b) => str += b.displayValue, '');\r\n        }\r\n        appendTail(tail) {\r\n            return super.appendTail(tail).aggregate(this._appendPlaceholder());\r\n        }\r\n        _appendEager() {\r\n            var _this$_mapPosToBlock;\r\n            const details = new ChangeDetails();\r\n            let startBlockIndex = (_this$_mapPosToBlock = this._mapPosToBlock(this.displayValue.length)) == null ? void 0 : _this$_mapPosToBlock.index;\r\n            if (startBlockIndex == null) return details;\r\n\r\n            // TODO test if it works for nested pattern masks\r\n            if (this._blocks[startBlockIndex].isFilled) ++startBlockIndex;\r\n            for (let bi = startBlockIndex; bi < this._blocks.length; ++bi) {\r\n                const d = this._blocks[bi]._appendEager();\r\n                if (!d.inserted) break;\r\n                details.aggregate(d);\r\n            }\r\n            return details;\r\n        }\r\n        _appendCharRaw(ch, flags) {\r\n            if (flags === void 0) {\r\n                flags = {};\r\n            }\r\n            const blockIter = this._mapPosToBlock(this.displayValue.length);\r\n            const details = new ChangeDetails();\r\n            if (!blockIter) return details;\r\n            for (let bi = blockIter.index, block; block = this._blocks[bi]; ++bi) {\r\n                var _flags$_beforeTailSta;\r\n                const blockDetails = block._appendChar(ch, {\r\n                    ...flags,\r\n                    _beforeTailState: (_flags$_beforeTailSta = flags._beforeTailState) == null || (_flags$_beforeTailSta = _flags$_beforeTailSta._blocks) == null ? void 0 : _flags$_beforeTailSta[bi]\r\n                });\r\n                details.aggregate(blockDetails);\r\n                if (blockDetails.consumed) break; // go next char\r\n            }\r\n            return details;\r\n        }\r\n        extractTail(fromPos, toPos) {\r\n            if (fromPos === void 0) {\r\n                fromPos = 0;\r\n            }\r\n            if (toPos === void 0) {\r\n                toPos = this.displayValue.length;\r\n            }\r\n            const chunkTail = new ChunksTailDetails();\r\n            if (fromPos === toPos) return chunkTail;\r\n            this._forEachBlocksInRange(fromPos, toPos, (b, bi, bFromPos, bToPos) => {\r\n                const blockChunk = b.extractTail(bFromPos, bToPos);\r\n                blockChunk.stop = this._findStopBefore(bi);\r\n                blockChunk.from = this._blockStartPos(bi);\r\n                if (blockChunk instanceof ChunksTailDetails) blockChunk.blockIndex = bi;\r\n                chunkTail.extend(blockChunk);\r\n            });\r\n            return chunkTail;\r\n        }\r\n        extractInput(fromPos, toPos, flags) {\r\n            if (fromPos === void 0) {\r\n                fromPos = 0;\r\n            }\r\n            if (toPos === void 0) {\r\n                toPos = this.displayValue.length;\r\n            }\r\n            if (flags === void 0) {\r\n                flags = {};\r\n            }\r\n            if (fromPos === toPos) return '';\r\n            let input = '';\r\n            this._forEachBlocksInRange(fromPos, toPos, (b, _, fromPos, toPos) => {\r\n                input += b.extractInput(fromPos, toPos, flags);\r\n            });\r\n            return input;\r\n        }\r\n        _findStopBefore(blockIndex) {\r\n            let stopBefore;\r\n            for (let si = 0; si < this._stops.length; ++si) {\r\n                const stop = this._stops[si];\r\n                if (stop <= blockIndex) stopBefore = stop;else break;\r\n            }\r\n            return stopBefore;\r\n        }\r\n\r\n        /** Appends placeholder depending on laziness */\r\n        _appendPlaceholder(toBlockIndex) {\r\n            const details = new ChangeDetails();\r\n            if (this.lazy && toBlockIndex == null) return details;\r\n            const startBlockIter = this._mapPosToBlock(this.displayValue.length);\r\n            if (!startBlockIter) return details;\r\n            const startBlockIndex = startBlockIter.index;\r\n            const endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;\r\n            this._blocks.slice(startBlockIndex, endBlockIndex).forEach(b => {\r\n                if (!b.lazy || toBlockIndex != null) {\r\n                    var _blocks2;\r\n                    details.aggregate(b._appendPlaceholder((_blocks2 = b._blocks) == null ? void 0 : _blocks2.length));\r\n                }\r\n            });\r\n            return details;\r\n        }\r\n\r\n        /** Finds block in pos */\r\n        _mapPosToBlock(pos) {\r\n            let accVal = '';\r\n            for (let bi = 0; bi < this._blocks.length; ++bi) {\r\n                const block = this._blocks[bi];\r\n                const blockStartPos = accVal.length;\r\n                accVal += block.displayValue;\r\n                if (pos <= accVal.length) {\r\n                    return {\r\n                        index: bi,\r\n                        offset: pos - blockStartPos\r\n                    };\r\n                }\r\n            }\r\n        }\r\n        _blockStartPos(blockIndex) {\r\n            return this._blocks.slice(0, blockIndex).reduce((pos, b) => pos += b.displayValue.length, 0);\r\n        }\r\n        _forEachBlocksInRange(fromPos, toPos, fn) {\r\n            if (toPos === void 0) {\r\n                toPos = this.displayValue.length;\r\n            }\r\n            const fromBlockIter = this._mapPosToBlock(fromPos);\r\n            if (fromBlockIter) {\r\n                const toBlockIter = this._mapPosToBlock(toPos);\r\n                // process first block\r\n                const isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;\r\n                const fromBlockStartPos = fromBlockIter.offset;\r\n                const fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].displayValue.length;\r\n                fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);\r\n                if (toBlockIter && !isSameBlock) {\r\n                    // process intermediate blocks\r\n                    for (let bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {\r\n                        fn(this._blocks[bi], bi, 0, this._blocks[bi].displayValue.length);\r\n                    }\r\n\r\n                    // process last block\r\n                    fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);\r\n                }\r\n            }\r\n        }\r\n        remove(fromPos, toPos) {\r\n            if (fromPos === void 0) {\r\n                fromPos = 0;\r\n            }\r\n            if (toPos === void 0) {\r\n                toPos = this.displayValue.length;\r\n            }\r\n            const removeDetails = super.remove(fromPos, toPos);\r\n            this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {\r\n                removeDetails.aggregate(b.remove(bFromPos, bToPos));\r\n            });\r\n            return removeDetails;\r\n        }\r\n        nearestInputPos(cursorPos, direction) {\r\n            if (direction === void 0) {\r\n                direction = DIRECTION.NONE;\r\n            }\r\n            if (!this._blocks.length) return 0;\r\n            const cursor = new PatternCursor(this, cursorPos);\r\n            if (direction === DIRECTION.NONE) {\r\n                // -------------------------------------------------\r\n                // NONE should only go out from fixed to the right!\r\n                // -------------------------------------------------\r\n                if (cursor.pushRightBeforeInput()) return cursor.pos;\r\n                cursor.popState();\r\n                if (cursor.pushLeftBeforeInput()) return cursor.pos;\r\n                return this.displayValue.length;\r\n            }\r\n\r\n            // FORCE is only about a|* otherwise is 0\r\n            if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {\r\n                // try to break fast when *|a\r\n                if (direction === DIRECTION.LEFT) {\r\n                    cursor.pushRightBeforeFilled();\r\n                    if (cursor.ok && cursor.pos === cursorPos) return cursorPos;\r\n                    cursor.popState();\r\n                }\r\n\r\n                // forward flow\r\n                cursor.pushLeftBeforeInput();\r\n                cursor.pushLeftBeforeRequired();\r\n                cursor.pushLeftBeforeFilled();\r\n\r\n                // backward flow\r\n                if (direction === DIRECTION.LEFT) {\r\n                    cursor.pushRightBeforeInput();\r\n                    cursor.pushRightBeforeRequired();\r\n                    if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\r\n                    cursor.popState();\r\n                    if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\r\n                    cursor.popState();\r\n                }\r\n                if (cursor.ok) return cursor.pos;\r\n                if (direction === DIRECTION.FORCE_LEFT) return 0;\r\n                cursor.popState();\r\n                if (cursor.ok) return cursor.pos;\r\n                cursor.popState();\r\n                if (cursor.ok) return cursor.pos;\r\n                return 0;\r\n            }\r\n            if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {\r\n                // forward flow\r\n                cursor.pushRightBeforeInput();\r\n                cursor.pushRightBeforeRequired();\r\n                if (cursor.pushRightBeforeFilled()) return cursor.pos;\r\n                if (direction === DIRECTION.FORCE_RIGHT) return this.displayValue.length;\r\n\r\n                // backward flow\r\n                cursor.popState();\r\n                if (cursor.ok) return cursor.pos;\r\n                cursor.popState();\r\n                if (cursor.ok) return cursor.pos;\r\n                return this.nearestInputPos(cursorPos, DIRECTION.LEFT);\r\n            }\r\n            return cursorPos;\r\n        }\r\n        totalInputPositions(fromPos, toPos) {\r\n            if (fromPos === void 0) {\r\n                fromPos = 0;\r\n            }\r\n            if (toPos === void 0) {\r\n                toPos = this.displayValue.length;\r\n            }\r\n            let total = 0;\r\n            this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {\r\n                total += b.totalInputPositions(bFromPos, bToPos);\r\n            });\r\n            return total;\r\n        }\r\n\r\n        /** Get block by name */\r\n        maskedBlock(name) {\r\n            return this.maskedBlocks(name)[0];\r\n        }\r\n\r\n        /** Get all blocks by name */\r\n        maskedBlocks(name) {\r\n            const indices = this._maskedBlocks[name];\r\n            if (!indices) return [];\r\n            return indices.map(gi => this._blocks[gi]);\r\n        }\r\n        pad(flags) {\r\n            const details = new ChangeDetails();\r\n            this._forEachBlocksInRange(0, this.displayValue.length, b => details.aggregate(b.pad(flags)));\r\n            return details;\r\n        }\r\n    }\r\n    MaskedPattern.DEFAULTS = {\r\n        ...Masked.DEFAULTS,\r\n        lazy: true,\r\n        placeholderChar: '_'\r\n    };\r\n    MaskedPattern.STOP_CHAR = '`';\r\n    MaskedPattern.ESCAPE_CHAR = '\\\\';\r\n    MaskedPattern.InputDefinition = PatternInputDefinition;\r\n    MaskedPattern.FixedDefinition = PatternFixedDefinition;\r\n    IMask.MaskedPattern = MaskedPattern;\r\n\r\n    /** Pattern which accepts ranges */\r\n    class MaskedRange extends MaskedPattern {\r\n        /**\r\n         Optionally sets max length of pattern.\r\n         Used when pattern length is longer then `to` param length. Pads zeros at start in this case.\r\n         */\r\n\r\n        /** Min bound */\r\n\r\n        /** Max bound */\r\n\r\n        get _matchFrom() {\r\n            return this.maxLength - String(this.from).length;\r\n        }\r\n        constructor(opts) {\r\n            super(opts); // mask will be created in _update\r\n        }\r\n        updateOptions(opts) {\r\n            super.updateOptions(opts);\r\n        }\r\n        _update(opts) {\r\n            const {\r\n                to = this.to || 0,\r\n                from = this.from || 0,\r\n                maxLength = this.maxLength || 0,\r\n                autofix = this.autofix,\r\n                ...patternOpts\r\n            } = opts;\r\n            this.to = to;\r\n            this.from = from;\r\n            this.maxLength = Math.max(String(to).length, maxLength);\r\n            this.autofix = autofix;\r\n            const fromStr = String(this.from).padStart(this.maxLength, '0');\r\n            const toStr = String(this.to).padStart(this.maxLength, '0');\r\n            let sameCharsCount = 0;\r\n            while (sameCharsCount < toStr.length && toStr[sameCharsCount] === fromStr[sameCharsCount]) ++sameCharsCount;\r\n            patternOpts.mask = toStr.slice(0, sameCharsCount).replace(/0/g, '\\\\0') + '0'.repeat(this.maxLength - sameCharsCount);\r\n            super._update(patternOpts);\r\n        }\r\n        get isComplete() {\r\n            return super.isComplete && Boolean(this.value);\r\n        }\r\n        boundaries(str) {\r\n            let minstr = '';\r\n            let maxstr = '';\r\n            const [, placeholder, num] = str.match(/^(\\D*)(\\d*)(\\D*)/) || [];\r\n            if (num) {\r\n                minstr = '0'.repeat(placeholder.length) + num;\r\n                maxstr = '9'.repeat(placeholder.length) + num;\r\n            }\r\n            minstr = minstr.padEnd(this.maxLength, '0');\r\n            maxstr = maxstr.padEnd(this.maxLength, '9');\r\n            return [minstr, maxstr];\r\n        }\r\n        doPrepareChar(ch, flags) {\r\n            if (flags === void 0) {\r\n                flags = {};\r\n            }\r\n            let details;\r\n            [ch, details] = super.doPrepareChar(ch.replace(/\\D/g, ''), flags);\r\n            if (!ch) details.skip = !this.isComplete;\r\n            return [ch, details];\r\n        }\r\n        _appendCharRaw(ch, flags) {\r\n            if (flags === void 0) {\r\n                flags = {};\r\n            }\r\n            if (!this.autofix || this.value.length + 1 > this.maxLength) return super._appendCharRaw(ch, flags);\r\n            const fromStr = String(this.from).padStart(this.maxLength, '0');\r\n            const toStr = String(this.to).padStart(this.maxLength, '0');\r\n            const [minstr, maxstr] = this.boundaries(this.value + ch);\r\n            if (Number(maxstr) < this.from) return super._appendCharRaw(fromStr[this.value.length], flags);\r\n            if (Number(minstr) > this.to) {\r\n                if (!flags.tail && this.autofix === 'pad' && this.value.length + 1 < this.maxLength) {\r\n                    return super._appendCharRaw(fromStr[this.value.length], flags).aggregate(this._appendCharRaw(ch, flags));\r\n                }\r\n                return super._appendCharRaw(toStr[this.value.length], flags);\r\n            }\r\n            return super._appendCharRaw(ch, flags);\r\n        }\r\n        doValidate(flags) {\r\n            const str = this.value;\r\n            const firstNonZero = str.search(/[^0]/);\r\n            if (firstNonZero === -1 && str.length <= this._matchFrom) return true;\r\n            const [minstr, maxstr] = this.boundaries(str);\r\n            return this.from <= Number(maxstr) && Number(minstr) <= this.to && super.doValidate(flags);\r\n        }\r\n        pad(flags) {\r\n            const details = new ChangeDetails();\r\n            if (this.value.length === this.maxLength) return details;\r\n            const value = this.value;\r\n            const padLength = this.maxLength - this.value.length;\r\n            if (padLength) {\r\n                this.reset();\r\n                for (let i = 0; i < padLength; ++i) {\r\n                    details.aggregate(super._appendCharRaw('0', flags));\r\n                }\r\n\r\n                // append tail\r\n                value.split('').forEach(ch => this._appendCharRaw(ch));\r\n            }\r\n            return details;\r\n        }\r\n    }\r\n    IMask.MaskedRange = MaskedRange;\r\n\r\n    const DefaultPattern = 'd{.}`m{.}`Y';\r\n\r\n    // Make format and parse required when pattern is provided\r\n\r\n    /** Date mask */\r\n    class MaskedDate extends MaskedPattern {\r\n        static extractPatternOptions(opts) {\r\n            const {\r\n                mask,\r\n                pattern,\r\n                ...patternOpts\r\n            } = opts;\r\n            return {\r\n                ...patternOpts,\r\n                mask: isString(mask) ? mask : pattern\r\n            };\r\n        }\r\n\r\n        /** Pattern mask for date according to {@link MaskedDate#format} */\r\n\r\n        /** Start date */\r\n\r\n        /** End date */\r\n\r\n        /** Format typed value to string */\r\n\r\n        /** Parse string to get typed value */\r\n\r\n        constructor(opts) {\r\n            super(MaskedDate.extractPatternOptions({\r\n                ...MaskedDate.DEFAULTS,\r\n                ...opts\r\n            }));\r\n        }\r\n        updateOptions(opts) {\r\n            super.updateOptions(opts);\r\n        }\r\n        _update(opts) {\r\n            const {\r\n                mask,\r\n                pattern,\r\n                blocks,\r\n                ...patternOpts\r\n            } = {\r\n                ...MaskedDate.DEFAULTS,\r\n                ...opts\r\n            };\r\n            const patternBlocks = Object.assign({}, MaskedDate.GET_DEFAULT_BLOCKS());\r\n            // adjust year block\r\n            if (opts.min) patternBlocks.Y.from = opts.min.getFullYear();\r\n            if (opts.max) patternBlocks.Y.to = opts.max.getFullYear();\r\n            if (opts.min && opts.max && patternBlocks.Y.from === patternBlocks.Y.to) {\r\n                patternBlocks.m.from = opts.min.getMonth() + 1;\r\n                patternBlocks.m.to = opts.max.getMonth() + 1;\r\n                if (patternBlocks.m.from === patternBlocks.m.to) {\r\n                    patternBlocks.d.from = opts.min.getDate();\r\n                    patternBlocks.d.to = opts.max.getDate();\r\n                }\r\n            }\r\n            Object.assign(patternBlocks, this.blocks, blocks);\r\n            super._update({\r\n                ...patternOpts,\r\n                mask: isString(mask) ? mask : pattern,\r\n                blocks: patternBlocks\r\n            });\r\n        }\r\n        doValidate(flags) {\r\n            const date = this.date;\r\n            return super.doValidate(flags) && (!this.isComplete || this.isDateExist(this.value) && date != null && (this.min == null || this.min <= date) && (this.max == null || date <= this.max));\r\n        }\r\n\r\n        /** Checks if date is exists */\r\n        isDateExist(str) {\r\n            return this.format(this.parse(str, this), this).indexOf(str) >= 0;\r\n        }\r\n\r\n        /** Parsed Date */\r\n        get date() {\r\n            return this.typedValue;\r\n        }\r\n        set date(date) {\r\n            this.typedValue = date;\r\n        }\r\n        get typedValue() {\r\n            return this.isComplete ? super.typedValue : null;\r\n        }\r\n        set typedValue(value) {\r\n            super.typedValue = value;\r\n        }\r\n        maskEquals(mask) {\r\n            return mask === Date || super.maskEquals(mask);\r\n        }\r\n        optionsIsChanged(opts) {\r\n            return super.optionsIsChanged(MaskedDate.extractPatternOptions(opts));\r\n        }\r\n    }\r\n    MaskedDate.GET_DEFAULT_BLOCKS = () => ({\r\n        d: {\r\n            mask: MaskedRange,\r\n            from: 1,\r\n            to: 31,\r\n            maxLength: 2\r\n        },\r\n        m: {\r\n            mask: MaskedRange,\r\n            from: 1,\r\n            to: 12,\r\n            maxLength: 2\r\n        },\r\n        Y: {\r\n            mask: MaskedRange,\r\n            from: 1900,\r\n            to: 9999\r\n        }\r\n    });\r\n    MaskedDate.DEFAULTS = {\r\n        ...MaskedPattern.DEFAULTS,\r\n        mask: Date,\r\n        pattern: DefaultPattern,\r\n        format: (date, masked) => {\r\n            if (!date) return '';\r\n            const day = String(date.getDate()).padStart(2, '0');\r\n            const month = String(date.getMonth() + 1).padStart(2, '0');\r\n            const year = date.getFullYear();\r\n            return [day, month, year].join('.');\r\n        },\r\n        parse: (str, masked) => {\r\n            const [day, month, year] = str.split('.').map(Number);\r\n            return new Date(year, month - 1, day);\r\n        }\r\n    };\r\n    IMask.MaskedDate = MaskedDate;\r\n\r\n    /** Dynamic mask for choosing appropriate mask in run-time */\r\n    class MaskedDynamic extends Masked {\r\n        constructor(opts) {\r\n            super({\r\n                ...MaskedDynamic.DEFAULTS,\r\n                ...opts\r\n            });\r\n            this.currentMask = undefined;\r\n        }\r\n        updateOptions(opts) {\r\n            super.updateOptions(opts);\r\n        }\r\n        _update(opts) {\r\n            super._update(opts);\r\n            if ('mask' in opts) {\r\n                this.exposeMask = undefined;\r\n                // mask could be totally dynamic with only `dispatch` option\r\n                this.compiledMasks = Array.isArray(opts.mask) ? opts.mask.map(m => {\r\n                    const {\r\n                        expose,\r\n                        ...maskOpts\r\n                    } = normalizeOpts(m);\r\n                    const masked = createMask({\r\n                        overwrite: this._overwrite,\r\n                        eager: this._eager,\r\n                        skipInvalid: this._skipInvalid,\r\n                        ...maskOpts\r\n                    });\r\n                    if (expose) this.exposeMask = masked;\r\n                    return masked;\r\n                }) : [];\r\n\r\n                // this.currentMask = this.doDispatch(''); // probably not needed but lets see\r\n            }\r\n        }\r\n        _appendCharRaw(ch, flags) {\r\n            if (flags === void 0) {\r\n                flags = {};\r\n            }\r\n            const details = this._applyDispatch(ch, flags);\r\n            if (this.currentMask) {\r\n                details.aggregate(this.currentMask._appendChar(ch, this.currentMaskFlags(flags)));\r\n            }\r\n            return details;\r\n        }\r\n        _applyDispatch(appended, flags, tail) {\r\n            if (appended === void 0) {\r\n                appended = '';\r\n            }\r\n            if (flags === void 0) {\r\n                flags = {};\r\n            }\r\n            if (tail === void 0) {\r\n                tail = '';\r\n            }\r\n            const prevValueBeforeTail = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._value : this.value;\r\n            const inputValue = this.rawInputValue;\r\n            const insertValue = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._rawInputValue : inputValue;\r\n            const tailValue = inputValue.slice(insertValue.length);\r\n            const prevMask = this.currentMask;\r\n            const details = new ChangeDetails();\r\n            const prevMaskState = prevMask == null ? void 0 : prevMask.state;\r\n\r\n            // clone flags to prevent overwriting `_beforeTailState`\r\n            this.currentMask = this.doDispatch(appended, {\r\n                ...flags\r\n            }, tail);\r\n\r\n            // restore state after dispatch\r\n            if (this.currentMask) {\r\n                if (this.currentMask !== prevMask) {\r\n                    // if mask changed reapply input\r\n                    this.currentMask.reset();\r\n                    if (insertValue) {\r\n                        this.currentMask.append(insertValue, {\r\n                            raw: true\r\n                        });\r\n                        details.tailShift = this.currentMask.value.length - prevValueBeforeTail.length;\r\n                    }\r\n                    if (tailValue) {\r\n                        details.tailShift += this.currentMask.append(tailValue, {\r\n                            raw: true,\r\n                            tail: true\r\n                        }).tailShift;\r\n                    }\r\n                } else if (prevMaskState) {\r\n                    // Dispatch can do something bad with state, so\r\n                    // restore prev mask state\r\n                    this.currentMask.state = prevMaskState;\r\n                }\r\n            }\r\n            return details;\r\n        }\r\n        _appendPlaceholder() {\r\n            const details = this._applyDispatch();\r\n            if (this.currentMask) {\r\n                details.aggregate(this.currentMask._appendPlaceholder());\r\n            }\r\n            return details;\r\n        }\r\n        _appendEager() {\r\n            const details = this._applyDispatch();\r\n            if (this.currentMask) {\r\n                details.aggregate(this.currentMask._appendEager());\r\n            }\r\n            return details;\r\n        }\r\n        appendTail(tail) {\r\n            const details = new ChangeDetails();\r\n            if (tail) details.aggregate(this._applyDispatch('', {}, tail));\r\n            return details.aggregate(this.currentMask ? this.currentMask.appendTail(tail) : super.appendTail(tail));\r\n        }\r\n        currentMaskFlags(flags) {\r\n            var _flags$_beforeTailSta, _flags$_beforeTailSta2;\r\n            return {\r\n                ...flags,\r\n                _beforeTailState: ((_flags$_beforeTailSta = flags._beforeTailState) == null ? void 0 : _flags$_beforeTailSta.currentMaskRef) === this.currentMask && ((_flags$_beforeTailSta2 = flags._beforeTailState) == null ? void 0 : _flags$_beforeTailSta2.currentMask) || flags._beforeTailState\r\n            };\r\n        }\r\n        doDispatch(appended, flags, tail) {\r\n            if (flags === void 0) {\r\n                flags = {};\r\n            }\r\n            if (tail === void 0) {\r\n                tail = '';\r\n            }\r\n            return this.dispatch(appended, this, flags, tail);\r\n        }\r\n        doValidate(flags) {\r\n            return super.doValidate(flags) && (!this.currentMask || this.currentMask.doValidate(this.currentMaskFlags(flags)));\r\n        }\r\n        doPrepare(str, flags) {\r\n            if (flags === void 0) {\r\n                flags = {};\r\n            }\r\n            let [s, details] = super.doPrepare(str, flags);\r\n            if (this.currentMask) {\r\n                let currentDetails;\r\n                [s, currentDetails] = super.doPrepare(s, this.currentMaskFlags(flags));\r\n                details = details.aggregate(currentDetails);\r\n            }\r\n            return [s, details];\r\n        }\r\n        doPrepareChar(str, flags) {\r\n            if (flags === void 0) {\r\n                flags = {};\r\n            }\r\n            let [s, details] = super.doPrepareChar(str, flags);\r\n            if (this.currentMask) {\r\n                let currentDetails;\r\n                [s, currentDetails] = super.doPrepareChar(s, this.currentMaskFlags(flags));\r\n                details = details.aggregate(currentDetails);\r\n            }\r\n            return [s, details];\r\n        }\r\n        reset() {\r\n            var _this$currentMask;\r\n            (_this$currentMask = this.currentMask) == null || _this$currentMask.reset();\r\n            this.compiledMasks.forEach(m => m.reset());\r\n        }\r\n        get value() {\r\n            return this.exposeMask ? this.exposeMask.value : this.currentMask ? this.currentMask.value : '';\r\n        }\r\n        set value(value) {\r\n            if (this.exposeMask) {\r\n                this.exposeMask.value = value;\r\n                this.currentMask = this.exposeMask;\r\n                this._applyDispatch();\r\n            } else super.value = value;\r\n        }\r\n        get unmaskedValue() {\r\n            return this.exposeMask ? this.exposeMask.unmaskedValue : this.currentMask ? this.currentMask.unmaskedValue : '';\r\n        }\r\n        set unmaskedValue(unmaskedValue) {\r\n            if (this.exposeMask) {\r\n                this.exposeMask.unmaskedValue = unmaskedValue;\r\n                this.currentMask = this.exposeMask;\r\n                this._applyDispatch();\r\n            } else super.unmaskedValue = unmaskedValue;\r\n        }\r\n        get typedValue() {\r\n            return this.exposeMask ? this.exposeMask.typedValue : this.currentMask ? this.currentMask.typedValue : '';\r\n        }\r\n        set typedValue(typedValue) {\r\n            if (this.exposeMask) {\r\n                this.exposeMask.typedValue = typedValue;\r\n                this.currentMask = this.exposeMask;\r\n                this._applyDispatch();\r\n                return;\r\n            }\r\n            let unmaskedValue = String(typedValue);\r\n\r\n            // double check it\r\n            if (this.currentMask) {\r\n                this.currentMask.typedValue = typedValue;\r\n                unmaskedValue = this.currentMask.unmaskedValue;\r\n            }\r\n            this.unmaskedValue = unmaskedValue;\r\n        }\r\n        get displayValue() {\r\n            return this.currentMask ? this.currentMask.displayValue : '';\r\n        }\r\n        get isComplete() {\r\n            var _this$currentMask2;\r\n            return Boolean((_this$currentMask2 = this.currentMask) == null ? void 0 : _this$currentMask2.isComplete);\r\n        }\r\n        get isFilled() {\r\n            var _this$currentMask3;\r\n            return Boolean((_this$currentMask3 = this.currentMask) == null ? void 0 : _this$currentMask3.isFilled);\r\n        }\r\n        remove(fromPos, toPos) {\r\n            const details = new ChangeDetails();\r\n            if (this.currentMask) {\r\n                details.aggregate(this.currentMask.remove(fromPos, toPos))\r\n                    // update with dispatch\r\n                    .aggregate(this._applyDispatch());\r\n            }\r\n            return details;\r\n        }\r\n        get state() {\r\n            var _this$currentMask4;\r\n            return {\r\n                ...super.state,\r\n                _rawInputValue: this.rawInputValue,\r\n                compiledMasks: this.compiledMasks.map(m => m.state),\r\n                currentMaskRef: this.currentMask,\r\n                currentMask: (_this$currentMask4 = this.currentMask) == null ? void 0 : _this$currentMask4.state\r\n            };\r\n        }\r\n        set state(state) {\r\n            const {\r\n                compiledMasks,\r\n                currentMaskRef,\r\n                currentMask,\r\n                ...maskedState\r\n            } = state;\r\n            if (compiledMasks) this.compiledMasks.forEach((m, mi) => m.state = compiledMasks[mi]);\r\n            if (currentMaskRef != null) {\r\n                this.currentMask = currentMaskRef;\r\n                this.currentMask.state = currentMask;\r\n            }\r\n            super.state = maskedState;\r\n        }\r\n        extractInput(fromPos, toPos, flags) {\r\n            return this.currentMask ? this.currentMask.extractInput(fromPos, toPos, flags) : '';\r\n        }\r\n        extractTail(fromPos, toPos) {\r\n            return this.currentMask ? this.currentMask.extractTail(fromPos, toPos) : super.extractTail(fromPos, toPos);\r\n        }\r\n        doCommit() {\r\n            if (this.currentMask) this.currentMask.doCommit();\r\n            super.doCommit();\r\n        }\r\n        nearestInputPos(cursorPos, direction) {\r\n            return this.currentMask ? this.currentMask.nearestInputPos(cursorPos, direction) : super.nearestInputPos(cursorPos, direction);\r\n        }\r\n        get overwrite() {\r\n            return this.currentMask ? this.currentMask.overwrite : this._overwrite;\r\n        }\r\n        set overwrite(overwrite) {\r\n            this._overwrite = overwrite;\r\n        }\r\n        get eager() {\r\n            return this.currentMask ? this.currentMask.eager : this._eager;\r\n        }\r\n        set eager(eager) {\r\n            this._eager = eager;\r\n        }\r\n        get skipInvalid() {\r\n            return this.currentMask ? this.currentMask.skipInvalid : this._skipInvalid;\r\n        }\r\n        set skipInvalid(skipInvalid) {\r\n            this._skipInvalid = skipInvalid;\r\n        }\r\n        get autofix() {\r\n            return this.currentMask ? this.currentMask.autofix : this._autofix;\r\n        }\r\n        set autofix(autofix) {\r\n            this._autofix = autofix;\r\n        }\r\n        maskEquals(mask) {\r\n            return Array.isArray(mask) ? this.compiledMasks.every((m, mi) => {\r\n                if (!mask[mi]) return;\r\n                const {\r\n                    mask: oldMask,\r\n                    ...restOpts\r\n                } = mask[mi];\r\n                return objectIncludes(m, restOpts) && m.maskEquals(oldMask);\r\n            }) : super.maskEquals(mask);\r\n        }\r\n        typedValueEquals(value) {\r\n            var _this$currentMask5;\r\n            return Boolean((_this$currentMask5 = this.currentMask) == null ? void 0 : _this$currentMask5.typedValueEquals(value));\r\n        }\r\n    }\r\n    /** Currently chosen mask */\r\n    /** Currently chosen mask */\r\n    /** Compliled {@link Masked} options */\r\n    /** Chooses {@link Masked} depending on input value */\r\n    MaskedDynamic.DEFAULTS = {\r\n        ...Masked.DEFAULTS,\r\n        dispatch: (appended, masked, flags, tail) => {\r\n            if (!masked.compiledMasks.length) return;\r\n            const inputValue = masked.rawInputValue;\r\n\r\n            // simulate input\r\n            const inputs = masked.compiledMasks.map((m, index) => {\r\n                const isCurrent = masked.currentMask === m;\r\n                const startInputPos = isCurrent ? m.displayValue.length : m.nearestInputPos(m.displayValue.length, DIRECTION.FORCE_LEFT);\r\n                if (m.rawInputValue !== inputValue) {\r\n                    m.reset();\r\n                    m.append(inputValue, {\r\n                        raw: true\r\n                    });\r\n                } else if (!isCurrent) {\r\n                    m.remove(startInputPos);\r\n                }\r\n                m.append(appended, masked.currentMaskFlags(flags));\r\n                m.appendTail(tail);\r\n                return {\r\n                    index,\r\n                    weight: m.rawInputValue.length,\r\n                    totalInputPositions: m.totalInputPositions(0, Math.max(startInputPos, m.nearestInputPos(m.displayValue.length, DIRECTION.FORCE_LEFT)))\r\n                };\r\n            });\r\n\r\n            // pop masks with longer values first\r\n            inputs.sort((i1, i2) => i2.weight - i1.weight || i2.totalInputPositions - i1.totalInputPositions);\r\n            return masked.compiledMasks[inputs[0].index];\r\n        }\r\n    };\r\n    IMask.MaskedDynamic = MaskedDynamic;\r\n\r\n    /** Pattern which validates enum values */\r\n    class MaskedEnum extends MaskedPattern {\r\n        constructor(opts) {\r\n            super({\r\n                ...MaskedEnum.DEFAULTS,\r\n                ...opts\r\n            }); // mask will be created in _update\r\n        }\r\n        updateOptions(opts) {\r\n            super.updateOptions(opts);\r\n        }\r\n        _update(opts) {\r\n            const {\r\n                enum: enum_,\r\n                ...eopts\r\n            } = opts;\r\n            if (enum_) {\r\n                const lengths = enum_.map(e => e.length);\r\n                const requiredLength = Math.min(...lengths);\r\n                const optionalLength = Math.max(...lengths) - requiredLength;\r\n                eopts.mask = '*'.repeat(requiredLength);\r\n                if (optionalLength) eopts.mask += '[' + '*'.repeat(optionalLength) + ']';\r\n                this.enum = enum_;\r\n            }\r\n            super._update(eopts);\r\n        }\r\n        _appendCharRaw(ch, flags) {\r\n            if (flags === void 0) {\r\n                flags = {};\r\n            }\r\n            const matchFrom = Math.min(this.nearestInputPos(0, DIRECTION.FORCE_RIGHT), this.value.length);\r\n            const matches = this.enum.filter(e => this.matchValue(e, this.unmaskedValue + ch, matchFrom));\r\n            if (matches.length) {\r\n                if (matches.length === 1) {\r\n                    this._forEachBlocksInRange(0, this.value.length, (b, bi) => {\r\n                        const mch = matches[0][bi];\r\n                        if (bi >= this.value.length || mch === b.value) return;\r\n                        b.reset();\r\n                        b._appendChar(mch, flags);\r\n                    });\r\n                }\r\n                const d = super._appendCharRaw(matches[0][this.value.length], flags);\r\n                if (matches.length === 1) {\r\n                    matches[0].slice(this.unmaskedValue.length).split('').forEach(mch => d.aggregate(super._appendCharRaw(mch)));\r\n                }\r\n                return d;\r\n            }\r\n            return new ChangeDetails({\r\n                skip: !this.isComplete\r\n            });\r\n        }\r\n        extractTail(fromPos, toPos) {\r\n            if (fromPos === void 0) {\r\n                fromPos = 0;\r\n            }\r\n            if (toPos === void 0) {\r\n                toPos = this.displayValue.length;\r\n            }\r\n            // just drop tail\r\n            return new ContinuousTailDetails('', fromPos);\r\n        }\r\n        remove(fromPos, toPos) {\r\n            if (fromPos === void 0) {\r\n                fromPos = 0;\r\n            }\r\n            if (toPos === void 0) {\r\n                toPos = this.displayValue.length;\r\n            }\r\n            if (fromPos === toPos) return new ChangeDetails();\r\n            const matchFrom = Math.min(super.nearestInputPos(0, DIRECTION.FORCE_RIGHT), this.value.length);\r\n            let pos;\r\n            for (pos = fromPos; pos >= 0; --pos) {\r\n                const matches = this.enum.filter(e => this.matchValue(e, this.value.slice(matchFrom, pos), matchFrom));\r\n                if (matches.length > 1) break;\r\n            }\r\n            const details = super.remove(pos, toPos);\r\n            details.tailShift += pos - fromPos;\r\n            return details;\r\n        }\r\n        get isComplete() {\r\n            return this.enum.indexOf(this.value) >= 0;\r\n        }\r\n    }\r\n    /** Match enum value */\r\n    MaskedEnum.DEFAULTS = {\r\n        ...MaskedPattern.DEFAULTS,\r\n        matchValue: (estr, istr, matchFrom) => estr.indexOf(istr, matchFrom) === matchFrom\r\n    };\r\n    IMask.MaskedEnum = MaskedEnum;\r\n\r\n    /** Masking by custom Function */\r\n    class MaskedFunction extends Masked {\r\n        /** */\r\n\r\n        /** Enable characters overwriting */\r\n\r\n        /** */\r\n\r\n        /** */\r\n\r\n        /** */\r\n\r\n        updateOptions(opts) {\r\n            super.updateOptions(opts);\r\n        }\r\n        _update(opts) {\r\n            super._update({\r\n                ...opts,\r\n                validate: opts.mask\r\n            });\r\n        }\r\n    }\r\n    IMask.MaskedFunction = MaskedFunction;\r\n\r\n    var _MaskedNumber;\r\n    /** Number mask */\r\n    class MaskedNumber extends Masked {\r\n        /** Single char */\r\n\r\n        /** Single char */\r\n\r\n        /** Array of single chars */\r\n\r\n        /** */\r\n\r\n        /** */\r\n\r\n        /** Digits after point */\r\n\r\n        /** Flag to remove leading and trailing zeros in the end of editing */\r\n\r\n        /** Flag to pad trailing zeros after point in the end of editing */\r\n\r\n        /** Enable characters overwriting */\r\n\r\n        /** */\r\n\r\n        /** */\r\n\r\n        /** */\r\n\r\n        /** Format typed value to string */\r\n\r\n        /** Parse string to get typed value */\r\n\r\n        constructor(opts) {\r\n            super({\r\n                ...MaskedNumber.DEFAULTS,\r\n                ...opts\r\n            });\r\n        }\r\n        updateOptions(opts) {\r\n            super.updateOptions(opts);\r\n        }\r\n        _update(opts) {\r\n            super._update(opts);\r\n            this._updateRegExps();\r\n        }\r\n        _updateRegExps() {\r\n            const start = '^' + (this.allowNegative ? '[+|\\\\-]?' : '');\r\n            const mid = '\\\\d*';\r\n            const end = (this.scale ? \"(\" + escapeRegExp(this.radix) + \"\\\\d{0,\" + this.scale + \"})?\" : '') + '$';\r\n            this._numberRegExp = new RegExp(start + mid + end);\r\n            this._mapToRadixRegExp = new RegExp(\"[\" + this.mapToRadix.map(escapeRegExp).join('') + \"]\", 'g');\r\n            this._thousandsSeparatorRegExp = new RegExp(escapeRegExp(this.thousandsSeparator), 'g');\r\n        }\r\n        _removeThousandsSeparators(value) {\r\n            return value.replace(this._thousandsSeparatorRegExp, '');\r\n        }\r\n        _insertThousandsSeparators(value) {\r\n            // https://stackoverflow.com/questions/2901102/how-to-print-a-number-with-commas-as-thousands-separators-in-javascript\r\n            const parts = value.split(this.radix);\r\n            parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, this.thousandsSeparator);\r\n            return parts.join(this.radix);\r\n        }\r\n        doPrepareChar(ch, flags) {\r\n            if (flags === void 0) {\r\n                flags = {};\r\n            }\r\n            const [prepCh, details] = super.doPrepareChar(this._removeThousandsSeparators(this.scale && this.mapToRadix.length && (\r\n                /*\r\n        radix should be mapped when\r\n        1) input is done from keyboard = flags.input && flags.raw\r\n        2) unmasked value is set = !flags.input && !flags.raw\r\n        and should not be mapped when\r\n        1) value is set = flags.input && !flags.raw\r\n        2) raw value is set = !flags.input && flags.raw\r\n      */\r\n                flags.input && flags.raw || !flags.input && !flags.raw) ? ch.replace(this._mapToRadixRegExp, this.radix) : ch), flags);\r\n            if (ch && !prepCh) details.skip = true;\r\n            if (prepCh && !this.allowPositive && !this.value && prepCh !== '-') details.aggregate(this._appendChar('-'));\r\n            return [prepCh, details];\r\n        }\r\n        _separatorsCount(to, extendOnSeparators) {\r\n            if (extendOnSeparators === void 0) {\r\n                extendOnSeparators = false;\r\n            }\r\n            let count = 0;\r\n            for (let pos = 0; pos < to; ++pos) {\r\n                if (this._value.indexOf(this.thousandsSeparator, pos) === pos) {\r\n                    ++count;\r\n                    if (extendOnSeparators) to += this.thousandsSeparator.length;\r\n                }\r\n            }\r\n            return count;\r\n        }\r\n        _separatorsCountFromSlice(slice) {\r\n            if (slice === void 0) {\r\n                slice = this._value;\r\n            }\r\n            return this._separatorsCount(this._removeThousandsSeparators(slice).length, true);\r\n        }\r\n        extractInput(fromPos, toPos, flags) {\r\n            if (fromPos === void 0) {\r\n                fromPos = 0;\r\n            }\r\n            if (toPos === void 0) {\r\n                toPos = this.displayValue.length;\r\n            }\r\n            [fromPos, toPos] = this._adjustRangeWithSeparators(fromPos, toPos);\r\n            return this._removeThousandsSeparators(super.extractInput(fromPos, toPos, flags));\r\n        }\r\n        _appendCharRaw(ch, flags) {\r\n            if (flags === void 0) {\r\n                flags = {};\r\n            }\r\n            const prevBeforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;\r\n            const prevBeforeTailSeparatorsCount = this._separatorsCountFromSlice(prevBeforeTailValue);\r\n            this._value = this._removeThousandsSeparators(this.value);\r\n            const oldValue = this._value;\r\n            this._value += ch;\r\n            const num = this.number;\r\n            let accepted = !isNaN(num);\r\n            let skip = false;\r\n            if (accepted) {\r\n                let fixedNum;\r\n                if (this.min != null && this.min < 0 && this.number < this.min) fixedNum = this.min;\r\n                if (this.max != null && this.max > 0 && this.number > this.max) fixedNum = this.max;\r\n                if (fixedNum != null) {\r\n                    if (this.autofix) {\r\n                        this._value = this.format(fixedNum, this).replace(MaskedNumber.UNMASKED_RADIX, this.radix);\r\n                        skip || (skip = oldValue === this._value && !flags.tail); // if not changed on tail it's still ok to proceed\r\n                    } else {\r\n                        accepted = false;\r\n                    }\r\n                }\r\n                accepted && (accepted = Boolean(this._value.match(this._numberRegExp)));\r\n            }\r\n            let appendDetails;\r\n            if (!accepted) {\r\n                this._value = oldValue;\r\n                appendDetails = new ChangeDetails();\r\n            } else {\r\n                appendDetails = new ChangeDetails({\r\n                    inserted: this._value.slice(oldValue.length),\r\n                    rawInserted: skip ? '' : ch,\r\n                    skip\r\n                });\r\n            }\r\n            this._value = this._insertThousandsSeparators(this._value);\r\n            const beforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;\r\n            const beforeTailSeparatorsCount = this._separatorsCountFromSlice(beforeTailValue);\r\n            appendDetails.tailShift += (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length;\r\n            return appendDetails;\r\n        }\r\n        _findSeparatorAround(pos) {\r\n            if (this.thousandsSeparator) {\r\n                const searchFrom = pos - this.thousandsSeparator.length + 1;\r\n                const separatorPos = this.value.indexOf(this.thousandsSeparator, searchFrom);\r\n                if (separatorPos <= pos) return separatorPos;\r\n            }\r\n            return -1;\r\n        }\r\n        _adjustRangeWithSeparators(from, to) {\r\n            const separatorAroundFromPos = this._findSeparatorAround(from);\r\n            if (separatorAroundFromPos >= 0) from = separatorAroundFromPos;\r\n            const separatorAroundToPos = this._findSeparatorAround(to);\r\n            if (separatorAroundToPos >= 0) to = separatorAroundToPos + this.thousandsSeparator.length;\r\n            return [from, to];\r\n        }\r\n        remove(fromPos, toPos) {\r\n            if (fromPos === void 0) {\r\n                fromPos = 0;\r\n            }\r\n            if (toPos === void 0) {\r\n                toPos = this.displayValue.length;\r\n            }\r\n            [fromPos, toPos] = this._adjustRangeWithSeparators(fromPos, toPos);\r\n            const valueBeforePos = this.value.slice(0, fromPos);\r\n            const valueAfterPos = this.value.slice(toPos);\r\n            const prevBeforeTailSeparatorsCount = this._separatorsCount(valueBeforePos.length);\r\n            this._value = this._insertThousandsSeparators(this._removeThousandsSeparators(valueBeforePos + valueAfterPos));\r\n            const beforeTailSeparatorsCount = this._separatorsCountFromSlice(valueBeforePos);\r\n            return new ChangeDetails({\r\n                tailShift: (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length\r\n            });\r\n        }\r\n        nearestInputPos(cursorPos, direction) {\r\n            if (!this.thousandsSeparator) return cursorPos;\r\n            switch (direction) {\r\n                case DIRECTION.NONE:\r\n                case DIRECTION.LEFT:\r\n                case DIRECTION.FORCE_LEFT:\r\n                {\r\n                    const separatorAtLeftPos = this._findSeparatorAround(cursorPos - 1);\r\n                    if (separatorAtLeftPos >= 0) {\r\n                        const separatorAtLeftEndPos = separatorAtLeftPos + this.thousandsSeparator.length;\r\n                        if (cursorPos < separatorAtLeftEndPos || this.value.length <= separatorAtLeftEndPos || direction === DIRECTION.FORCE_LEFT) {\r\n                            return separatorAtLeftPos;\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n                case DIRECTION.RIGHT:\r\n                case DIRECTION.FORCE_RIGHT:\r\n                {\r\n                    const separatorAtRightPos = this._findSeparatorAround(cursorPos);\r\n                    if (separatorAtRightPos >= 0) {\r\n                        return separatorAtRightPos + this.thousandsSeparator.length;\r\n                    }\r\n                }\r\n            }\r\n            return cursorPos;\r\n        }\r\n        doCommit() {\r\n            if (this.value) {\r\n                const number = this.number;\r\n                let validnum = number;\r\n\r\n                // check bounds\r\n                if (this.min != null) validnum = Math.max(validnum, this.min);\r\n                if (this.max != null) validnum = Math.min(validnum, this.max);\r\n                if (validnum !== number) this.unmaskedValue = this.format(validnum, this);\r\n                let formatted = this.value;\r\n                if (this.normalizeZeros) formatted = this._normalizeZeros(formatted);\r\n                if (this.padFractionalZeros && this.scale > 0) formatted = this._padFractionalZeros(formatted);\r\n                this._value = formatted;\r\n            }\r\n            super.doCommit();\r\n        }\r\n        _normalizeZeros(value) {\r\n            const parts = this._removeThousandsSeparators(value).split(this.radix);\r\n\r\n            // remove leading zeros\r\n            parts[0] = parts[0].replace(/^(\\D*)(0*)(\\d*)/, (match, sign, zeros, num) => sign + num);\r\n            // add leading zero\r\n            if (value.length && !/\\d$/.test(parts[0])) parts[0] = parts[0] + '0';\r\n            if (parts.length > 1) {\r\n                parts[1] = parts[1].replace(/0*$/, ''); // remove trailing zeros\r\n                if (!parts[1].length) parts.length = 1; // remove fractional\r\n            }\r\n            return this._insertThousandsSeparators(parts.join(this.radix));\r\n        }\r\n        _padFractionalZeros(value) {\r\n            if (!value) return value;\r\n            const parts = value.split(this.radix);\r\n            if (parts.length < 2) parts.push('');\r\n            parts[1] = parts[1].padEnd(this.scale, '0');\r\n            return parts.join(this.radix);\r\n        }\r\n        doSkipInvalid(ch, flags, checkTail) {\r\n            if (flags === void 0) {\r\n                flags = {};\r\n            }\r\n            const dropFractional = this.scale === 0 && ch !== this.thousandsSeparator && (ch === this.radix || ch === MaskedNumber.UNMASKED_RADIX || this.mapToRadix.includes(ch));\r\n            return super.doSkipInvalid(ch, flags, checkTail) && !dropFractional;\r\n        }\r\n        get unmaskedValue() {\r\n            return this._removeThousandsSeparators(this._normalizeZeros(this.value)).replace(this.radix, MaskedNumber.UNMASKED_RADIX);\r\n        }\r\n        set unmaskedValue(unmaskedValue) {\r\n            super.unmaskedValue = unmaskedValue;\r\n        }\r\n        get typedValue() {\r\n            return this.parse(this.unmaskedValue, this);\r\n        }\r\n        set typedValue(n) {\r\n            this.rawInputValue = this.format(n, this).replace(MaskedNumber.UNMASKED_RADIX, this.radix);\r\n        }\r\n\r\n        /** Parsed Number */\r\n        get number() {\r\n            return this.typedValue;\r\n        }\r\n        set number(number) {\r\n            this.typedValue = number;\r\n        }\r\n        get allowNegative() {\r\n            return this.min != null && this.min < 0 || this.max != null && this.max < 0;\r\n        }\r\n        get allowPositive() {\r\n            return this.min != null && this.min > 0 || this.max != null && this.max > 0;\r\n        }\r\n        typedValueEquals(value) {\r\n            // handle  0 -> '' case (typed = 0 even if value = '')\r\n            // for details see https://github.com/uNmAnNeR/imaskjs/issues/134\r\n            return (super.typedValueEquals(value) || MaskedNumber.EMPTY_VALUES.includes(value) && MaskedNumber.EMPTY_VALUES.includes(this.typedValue)) && !(value === 0 && this.value === '');\r\n        }\r\n    }\r\n    _MaskedNumber = MaskedNumber;\r\n    MaskedNumber.UNMASKED_RADIX = '.';\r\n    MaskedNumber.EMPTY_VALUES = [...Masked.EMPTY_VALUES, 0];\r\n    MaskedNumber.DEFAULTS = {\r\n        ...Masked.DEFAULTS,\r\n        mask: Number,\r\n        radix: ',',\r\n        thousandsSeparator: '',\r\n        mapToRadix: [_MaskedNumber.UNMASKED_RADIX],\r\n        min: Number.MIN_SAFE_INTEGER,\r\n        max: Number.MAX_SAFE_INTEGER,\r\n        scale: 2,\r\n        normalizeZeros: true,\r\n        padFractionalZeros: false,\r\n        parse: Number,\r\n        format: n => n.toLocaleString('en-US', {\r\n            useGrouping: false,\r\n            maximumFractionDigits: 20\r\n        })\r\n    };\r\n    IMask.MaskedNumber = MaskedNumber;\r\n\r\n    /** Mask pipe source and destination types */\r\n    const PIPE_TYPE = {\r\n        MASKED: 'value',\r\n        UNMASKED: 'unmaskedValue',\r\n        TYPED: 'typedValue'\r\n    };\r\n    /** Creates new pipe function depending on mask type, source and destination options */\r\n    function createPipe(arg, from, to) {\r\n        if (from === void 0) {\r\n            from = PIPE_TYPE.MASKED;\r\n        }\r\n        if (to === void 0) {\r\n            to = PIPE_TYPE.MASKED;\r\n        }\r\n        const masked = createMask(arg);\r\n        return value => masked.runIsolated(m => {\r\n            m[from] = value;\r\n            return m[to];\r\n        });\r\n    }\r\n\r\n    /** Pipes value through mask depending on mask type, source and destination options */\r\n    function pipe(value, mask, from, to) {\r\n        return createPipe(mask, from, to)(value);\r\n    }\r\n    IMask.PIPE_TYPE = PIPE_TYPE;\r\n    IMask.createPipe = createPipe;\r\n    IMask.pipe = pipe;\r\n\r\n    /** Pattern mask */\r\n    class RepeatBlock extends MaskedPattern {\r\n        get repeatFrom() {\r\n            var _ref;\r\n            return (_ref = Array.isArray(this.repeat) ? this.repeat[0] : this.repeat === Infinity ? 0 : this.repeat) != null ? _ref : 0;\r\n        }\r\n        get repeatTo() {\r\n            var _ref2;\r\n            return (_ref2 = Array.isArray(this.repeat) ? this.repeat[1] : this.repeat) != null ? _ref2 : Infinity;\r\n        }\r\n        constructor(opts) {\r\n            super(opts);\r\n        }\r\n        updateOptions(opts) {\r\n            super.updateOptions(opts);\r\n        }\r\n        _update(opts) {\r\n            var _ref3, _ref4, _this$_blocks;\r\n            const {\r\n                repeat,\r\n                ...blockOpts\r\n            } = normalizeOpts(opts); // TODO type\r\n            this._blockOpts = Object.assign({}, this._blockOpts, blockOpts);\r\n            const block = createMask(this._blockOpts);\r\n            this.repeat = (_ref3 = (_ref4 = repeat != null ? repeat : block.repeat) != null ? _ref4 : this.repeat) != null ? _ref3 : Infinity; // TODO type\r\n\r\n            super._update({\r\n                mask: 'm'.repeat(Math.max(this.repeatTo === Infinity && ((_this$_blocks = this._blocks) == null ? void 0 : _this$_blocks.length) || 0, this.repeatFrom)),\r\n                blocks: {\r\n                    m: block\r\n                },\r\n                eager: block.eager,\r\n                overwrite: block.overwrite,\r\n                skipInvalid: block.skipInvalid,\r\n                lazy: block.lazy,\r\n                placeholderChar: block.placeholderChar,\r\n                displayChar: block.displayChar\r\n            });\r\n        }\r\n        _allocateBlock(bi) {\r\n            if (bi < this._blocks.length) return this._blocks[bi];\r\n            if (this.repeatTo === Infinity || this._blocks.length < this.repeatTo) {\r\n                this._blocks.push(createMask(this._blockOpts));\r\n                this.mask += 'm';\r\n                return this._blocks[this._blocks.length - 1];\r\n            }\r\n        }\r\n        _appendCharRaw(ch, flags) {\r\n            if (flags === void 0) {\r\n                flags = {};\r\n            }\r\n            const details = new ChangeDetails();\r\n            for (let bi = (_this$_mapPosToBlock$ = (_this$_mapPosToBlock = this._mapPosToBlock(this.displayValue.length)) == null ? void 0 : _this$_mapPosToBlock.index) != null ? _this$_mapPosToBlock$ : Math.max(this._blocks.length - 1, 0), block, allocated;\r\n                // try to get a block or\r\n                // try to allocate a new block if not allocated already\r\n                 block = (_this$_blocks$bi = this._blocks[bi]) != null ? _this$_blocks$bi : allocated = !allocated && this._allocateBlock(bi); ++bi) {\r\n                var _this$_mapPosToBlock$, _this$_mapPosToBlock, _this$_blocks$bi, _flags$_beforeTailSta;\r\n                const blockDetails = block._appendChar(ch, {\r\n                    ...flags,\r\n                    _beforeTailState: (_flags$_beforeTailSta = flags._beforeTailState) == null || (_flags$_beforeTailSta = _flags$_beforeTailSta._blocks) == null ? void 0 : _flags$_beforeTailSta[bi]\r\n                });\r\n                if (blockDetails.skip && allocated) {\r\n                    // remove the last allocated block and break\r\n                    this._blocks.pop();\r\n                    this.mask = this.mask.slice(1);\r\n                    break;\r\n                }\r\n                details.aggregate(blockDetails);\r\n                if (blockDetails.consumed) break; // go next char\r\n            }\r\n            return details;\r\n        }\r\n        _trimEmptyTail(fromPos, toPos) {\r\n            var _this$_mapPosToBlock2, _this$_mapPosToBlock3;\r\n            if (fromPos === void 0) {\r\n                fromPos = 0;\r\n            }\r\n            const firstBlockIndex = Math.max(((_this$_mapPosToBlock2 = this._mapPosToBlock(fromPos)) == null ? void 0 : _this$_mapPosToBlock2.index) || 0, this.repeatFrom, 0);\r\n            let lastBlockIndex;\r\n            if (toPos != null) lastBlockIndex = (_this$_mapPosToBlock3 = this._mapPosToBlock(toPos)) == null ? void 0 : _this$_mapPosToBlock3.index;\r\n            if (lastBlockIndex == null) lastBlockIndex = this._blocks.length - 1;\r\n            let removeCount = 0;\r\n            for (let blockIndex = lastBlockIndex; firstBlockIndex <= blockIndex; --blockIndex, ++removeCount) {\r\n                if (this._blocks[blockIndex].unmaskedValue) break;\r\n            }\r\n            if (removeCount) {\r\n                this._blocks.splice(lastBlockIndex - removeCount + 1, removeCount);\r\n                this.mask = this.mask.slice(removeCount);\r\n            }\r\n        }\r\n        reset() {\r\n            super.reset();\r\n            this._trimEmptyTail();\r\n        }\r\n        remove(fromPos, toPos) {\r\n            if (fromPos === void 0) {\r\n                fromPos = 0;\r\n            }\r\n            if (toPos === void 0) {\r\n                toPos = this.displayValue.length;\r\n            }\r\n            const removeDetails = super.remove(fromPos, toPos);\r\n            this._trimEmptyTail(fromPos, toPos);\r\n            return removeDetails;\r\n        }\r\n        totalInputPositions(fromPos, toPos) {\r\n            if (fromPos === void 0) {\r\n                fromPos = 0;\r\n            }\r\n            if (toPos == null && this.repeatTo === Infinity) return Infinity;\r\n            return super.totalInputPositions(fromPos, toPos);\r\n        }\r\n        get state() {\r\n            return super.state;\r\n        }\r\n        set state(state) {\r\n            this._blocks.length = state._blocks.length;\r\n            this.mask = this.mask.slice(0, this._blocks.length);\r\n            super.state = state;\r\n        }\r\n    }\r\n    IMask.RepeatBlock = RepeatBlock;\r\n\r\n    try {\r\n        globalThis.IMask = IMask;\r\n    } catch {}\r\n\r\n    exports.ChangeDetails = ChangeDetails;\r\n    exports.ChunksTailDetails = ChunksTailDetails;\r\n    exports.DIRECTION = DIRECTION;\r\n    exports.HTMLContenteditableMaskElement = HTMLContenteditableMaskElement;\r\n    exports.HTMLInputMaskElement = HTMLInputMaskElement;\r\n    exports.HTMLMaskElement = HTMLMaskElement;\r\n    exports.InputMask = InputMask;\r\n    exports.MaskElement = MaskElement;\r\n    exports.Masked = Masked;\r\n    exports.MaskedDate = MaskedDate;\r\n    exports.MaskedDynamic = MaskedDynamic;\r\n    exports.MaskedEnum = MaskedEnum;\r\n    exports.MaskedFunction = MaskedFunction;\r\n    exports.MaskedNumber = MaskedNumber;\r\n    exports.MaskedPattern = MaskedPattern;\r\n    exports.MaskedRange = MaskedRange;\r\n    exports.MaskedRegExp = MaskedRegExp;\r\n    exports.PIPE_TYPE = PIPE_TYPE;\r\n    exports.PatternFixedDefinition = PatternFixedDefinition;\r\n    exports.PatternInputDefinition = PatternInputDefinition;\r\n    exports.RepeatBlock = RepeatBlock;\r\n    exports.createMask = createMask;\r\n    exports.createPipe = createPipe;\r\n    exports.default = IMask;\r\n    exports.forceDirection = forceDirection;\r\n    exports.normalizeOpts = normalizeOpts;\r\n    exports.pipe = pipe;\r\n\r\n    Object.defineProperty(exports, '__esModule', { value: true });\r\n\r\n}));\r\n//# sourceMappingURL=imask.js.map"],"names":["global","factory","this","exports","isString","str","String","isObject","obj","_obj$constructor","constructor","name","pick","keys","Array","isArray","_","k","includes","Object","entries","reduce","acc","_ref","v","DIRECTION","NONE","LEFT","FORCE_LEFT","RIGHT","FORCE_RIGHT","forceDirection","direction","escapeRegExp","replace","objectIncludes","b","a","arrA","arrB","i","length","dateA","Date","dateB","getTime","regexpA","RegExp","regexpB","toString","prototype","hasOwnProperty","call","ActionDetails","opts","assign","value","slice","startChangePos","oldValue","oldSelection","start","insertedCount","cursorPos","end","Math","min","inserted","substr","removedCount","max","removed","head","substring","tail","removeDirection","IMask","el","InputMask","maskedClass","mask","Error","MaskedRegExp","MaskedPattern","MaskedDate","Number","MaskedNumber","MaskedDynamic","Masked","Function","MaskedFunction","console","warn","normalizeOpts","instanceOpts","_mask","startsWith","createMask","nOpts","MaskedClass","MaskElement","selectionStart","_unsafeSelectionStart","selectionEnd","_unsafeSelectionEnd","select","_unsafeSelect","isActive","HTMLMaskElement","input","_onKeydown","bind","_onInput","_onBeforeinput","_onCompositionEnd","rootElement","_this$input$getRootNo","_this$input$getRootNo2","_this$input","getRootNode","document","activeElement","bindEvents","handlers","addEventListener","drop","click","focus","commit","_handlers","e","redo","keyCode","shiftKey","metaKey","ctrlKey","preventDefault","undo","isComposing","selectionChange","inputType","unbindEvents","removeEventListener","HTMLInputMaskElement","setSelectionRange","HTMLContenteditableMaskElement","root","selection","getSelection","anchorOffset","focusOffset","createRange","range","setStart","firstChild","setEnd","lastChild","removeAllRanges","addRange","textContent","InputHistory","states","currentIndex","currentState","isEmpty","push","state","MAX_LENGTH","shift","go","steps","clear","isContentEditable","tagName","masked","_listeners","_value","_unmaskedValue","_rawInputValue","history","_saveSelection","_onChange","_onDrop","_onFocus","_onClick","_onUndo","_onRedo","alignCursor","alignCursorFriendly","_bindEvents","updateValue","maskEquals","_this$masked","updateOptions","unmaskedValue","updateControl","rawInputValue","typedValue","val","typedValueEquals","displayValue","_unbindEvents","_fireEvent","ev","listeners","forEach","l","_cursorChanging","_changingCursorPos","pos","_selection","newUnmaskedValue","newValue","newRawInputValue","newDisplayValue","isChanged","_fireChangeEvents","_historyChanging","restOpts","updateMask","updateOpts","optionsIsChanged","updateCursor","_delayUpdateCursor","_abortUpdateCursor","setTimeout","_inputEvent","isComplete","clearTimeout","nearestInputPos","on","handler","off","hIndex","indexOf","splice","details","oldRawValue","offset","raw","doCommit","stopPropagation","_applyHistoryState","destroy","ChangeDetails","prep","rawInserted","tailShift","skip","aggregate","consumed","Boolean","equals","ContinuousTailDetails","from","stop","extend","appendTo","append","_appendPlaceholder","unshift","beforePos","shiftChar","_update","DEFAULTS","_initialized","withValueRefresh","reset","resolve","flags","parse","format","extractInput","isFilled","totalInputPositions","fromPos","toPos","extractTail","appendTail","_appendCharRaw","ch","_appendChar","checkTail","consistentState","doPrepareChar","autofix","noFixState","fixDetails","pad","chDetails","consistentTail","appended","doValidate","beforeTailState","overwrite","tailDetails","_appendEager","_beforeTailState","doPrepare","ci","d","doSkipInvalid","eager","remove","fn","_refreshing","rawInput","ret","runIsolated","_isolated","skipInvalid","normalize","prepare","prepareChar","validate","parent","deleteCount","tailPos","eagerRemove","valLength","tval","EMPTY_VALUES","undefined","ChunksTailDetails","chunks","map","join","tailChunk","lastChunk","extendLast","firstTailChunk","blockIndex","chunk","lastBlockIter","_mapPosToBlock","chunkBlock","index","_stops","_blocks","remainChars","c","props","cstate","chunkShiftPos","PatternCursor","_log","ok","block","_blockStartPos","s","pushState","popState","pop","bindBlock","_pushLeft","_this$block","_pushRight","pushLeftBeforeFilled","isFixed","pushLeftBeforeInput","pushLeftBeforeRequired","isOptional","pushRightBeforeFilled","pushRightBeforeInput","pushRightBeforeRequired","PatternFixedDefinition","isUnmasking","_isRawInput","maxPos","appendEager","isResolved","char","PatternInputDefinition","placeholderChar","displayChar","lazy","maskOpts","currentMaskFlags","boundPos","_flags$_beforeTailSta","DEFAULT_DEFINITIONS","search","definitions","_rebuildMask","defs","exposeBlock","_maskedBlocks","pattern","unmaskingBlock","optionalBlock","blocks","p","bNames","filter","bName","sort","expose","repeat","bOpts","blockOpts","maskedBlock","RepeatBlock","isInput","STOP_CHAR","ESCAPE_CHAR","def","super","maskedState","bi","every","_this$_mapPosToBlock","startBlockIndex","blockIter","blockDetails","chunkTail","_forEachBlocksInRange","bFromPos","bToPos","blockChunk","_findStopBefore","stopBefore","si","toBlockIndex","startBlockIter","endBlockIndex","_blocks2","accVal","blockStartPos","fromBlockIter","toBlockIter","isSameBlock","fromBlockStartPos","fromBlockEndPos","removeDetails","cursor","total","maskedBlocks","indices","gi","InputDefinition","FixedDefinition","MaskedRange","_matchFrom","maxLength","to","patternOpts","fromStr","padStart","toStr","sameCharsCount","boundaries","minstr","maxstr","placeholder","num","match","padEnd","padLength","split","extractPatternOptions","patternBlocks","GET_DEFAULT_BLOCKS","Y","getFullYear","m","getMonth","getDate","date","isDateExist","day","month","year","currentMask","exposeMask","compiledMasks","_overwrite","_eager","_skipInvalid","_applyDispatch","prevValueBeforeTail","inputValue","insertValue","tailValue","prevMask","prevMaskState","doDispatch","_flags$_beforeTailSta2","currentMaskRef","dispatch","currentDetails","_this$currentMask","_this$currentMask2","_this$currentMask3","_this$currentMask4","mi","_autofix","oldMask","_this$currentMask5","inputs","isCurrent","startInputPos","weight","i1","i2","MaskedEnum","enum","enum_","eopts","lengths","requiredLength","optionalLength","matchFrom","matches","matchValue","mch","estr","istr","_MaskedNumber","_updateRegExps","allowNegative","scale","radix","_numberRegExp","_mapToRadixRegExp","mapToRadix","_thousandsSeparatorRegExp","thousandsSeparator","_removeThousandsSeparators","_insertThousandsSeparators","parts","prepCh","allowPositive","_separatorsCount","extendOnSeparators","count","_separatorsCountFromSlice","_adjustRangeWithSeparators","prevBeforeTailValue","prevBeforeTailSeparatorsCount","number","appendDetails","accepted","isNaN","fixedNum","UNMASKED_RADIX","beforeTailValue","beforeTailSeparatorsCount","_findSeparatorAround","searchFrom","separatorPos","separatorAroundFromPos","separatorAroundToPos","valueBeforePos","valueAfterPos","separatorAtLeftPos","separatorAtLeftEndPos","separatorAtRightPos","validnum","formatted","normalizeZeros","_normalizeZeros","padFractionalZeros","_padFractionalZeros","sign","zeros","test","dropFractional","n","MIN_SAFE_INTEGER","MAX_SAFE_INTEGER","toLocaleString","useGrouping","maximumFractionDigits","PIPE_TYPE","MASKED","UNMASKED","TYPED","createPipe","arg","pipe","repeatFrom","Infinity","repeatTo","_ref2","_ref3","_ref4","_this$_blocks","_blockOpts","_allocateBlock","allocated","_this$_mapPosToBlock$","_this$_blocks$bi","_trimEmptyTail","_this$_mapPosToBlock2","_this$_mapPosToBlock3","firstBlockIndex","lastBlockIndex","removeCount","globalThis","default","defineProperty","module","define","amd","self"],"mappings":"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"}